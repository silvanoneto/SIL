// LIS Example: Tuplas
// Demonstra: Criacao e uso de tuplas
// Documentacao: Secao 6.10

// Function that creates a point (returns x for simplicity)
fn make_point(x: Int, y: Int) -> Int {
    // Simulacao - retornando apenas x por simplicidade
    return x;
}

// Create a vector3 using State as container
fn create_vector3(x: Float, y: Float, z: Float) -> State {
    let s = state_vacuum();
    let s = state_set_layer(s, 0, bytesil_from_complex(x, 0.0));
    let s = state_set_layer(s, 1, bytesil_from_complex(y, 0.0));
    let s = state_set_layer(s, 2, bytesil_from_complex(z, 0.0));
    return s;
}

// Compute statistics and return as State
fn compute_stats(a: Float, b: Float, c: Float) -> State {
    let sum = a + b + c;
    let avg = sum / 3.0;
    let min_val = min(min(a, b), c);
    let max_val = max(max(a, b), c);

    let result = state_vacuum();
    let result = state_set_layer(result, 0, bytesil_from_complex(sum, 0.0));
    let result = state_set_layer(result, 1, bytesil_from_complex(avg, 0.0));
    let result = state_set_layer(result, 2, bytesil_from_complex(min_val, 0.0));
    let result = state_set_layer(result, 3, bytesil_from_complex(max_val, 0.0));
    return result;
}

// Create a 2D point using State
fn create_point_2d(x: Float, y: Float) -> State {
    let s = state_vacuum();
    let s = state_set_layer(s, 0, bytesil_from_complex(x, 0.0));
    let s = state_set_layer(s, 1, bytesil_from_complex(y, 0.0));
    return s;
}

// Get x coordinate from point
fn get_x(point: State) -> Float {
    return bytesil_magnitude(state_get_layer(point, 0));
}

// Get y coordinate from point
fn get_y(point: State) -> Float {
    return bytesil_magnitude(state_get_layer(point, 1));
}

// Calculate distance between two points
fn distance_between(p1: State, p2: State) -> Float {
    let dx = get_x(p2) - get_x(p1);
    let dy = get_y(p2) - get_y(p1);
    return sqrt(dx * dx + dy * dy);
}

fn main() {
    print_string("=== Tuples ===");

    // =========================================
    // Criacao de Tuplas
    // =========================================
    print_string("--- Tuple Creation ---");

    // Tupla de 2 elementos (par)
    let pair = (1, 2);
    print_string("Created pair (1, 2)");

    // Tupla de 3 elementos (tripla)
    let triple = (10, 20, 30);
    print_string("Created triple (10, 20, 30)");

    // Tupla com tipos mistos
    let mixed = (42, 3.14);
    print_string("Created mixed tuple (42, 3.14)");

    // Tupla com strings
    let with_string = (1, "hello");
    print_string("Created tuple with string (1, hello)");

    // Tupla com booleanos
    let with_bool = (true, false);
    print_string("Created boolean tuple (true, false)");

    // =========================================
    // Tuplas Aninhadas
    // =========================================
    print_string("--- Nested Tuples ---");

    // Tupla de tuplas
    let nested = ((1, 2), (3, 4));
    print_string("Created nested tuple ((1,2), (3,4))");

    // =========================================
    // Tuplas em Funcoes
    // =========================================
    print_string("--- Tuples in Functions ---");

    // Funcao que retorna tupla (simulado com State)
    // Nota: LIS pode nao ter suporte completo a tuplas como retorno

    let point = make_point(10, 20);
    print_string("Created point x:");
    print_int(point);

    // =========================================
    // Padroes com Tuplas
    // =========================================
    print_string("--- Tuple Patterns ---");

    // Usar State como conteiner de valores multiplos
    let vec3 = create_vector3(1.0, 2.0, 3.0);
    print_string("Created vector3 using State as tuple:");

    let x_val = bytesil_magnitude(state_get_layer(vec3, 0));
    let y_val = bytesil_magnitude(state_get_layer(vec3, 1));
    let z_val = bytesil_magnitude(state_get_layer(vec3, 2));

    print_string("x:");
    print_float(x_val);
    print_string("y:");
    print_float(y_val);
    print_string("z:");
    print_float(z_val);

    // =========================================
    // Retorno de Multiplos Valores
    // =========================================
    print_string("--- Multiple Return Values ---");

    // Usando State para retornar multiplos valores
    let stats = compute_stats(10.0, 20.0, 15.0);

    print_string("Stats for (10, 20, 15):");
    print_string("Sum:");
    print_float(bytesil_magnitude(state_get_layer(stats, 0)));
    print_string("Average:");
    print_float(bytesil_magnitude(state_get_layer(stats, 1)));
    print_string("Min:");
    print_float(bytesil_magnitude(state_get_layer(stats, 2)));
    print_string("Max:");
    print_float(bytesil_magnitude(state_get_layer(stats, 3)));

    // =========================================
    // Coordenadas e Pontos
    // =========================================
    print_string("--- Coordinates and Points ---");

    let point1 = create_point_2d(0.0, 0.0);
    let point2 = create_point_2d(3.0, 4.0);

    let dist = distance_between(point1, point2);
    print_string("Distance from (0,0) to (3,4):");
    print_float(dist);  // Should be 5

    // =========================================
    // Complexo como Tupla
    // =========================================
    print_string("--- Complex as Tuple ---");

    // ByteSil pode ser visto como tupla (magnitude, phase)
    let complex_val = bytesil_from_complex(3.0, 4.0);

    print_string("Complex 3+4i as tuple:");
    print_string("  First (magnitude):");
    print_float(bytesil_magnitude(complex_val));
    print_string("  Second (phase):");
    print_float(bytesil_phase_radians(complex_val));

    print_string("=== Tuples Demo Complete ===");
}
