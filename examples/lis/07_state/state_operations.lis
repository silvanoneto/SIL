// LIS Example: Operações de Estado
// Demonstra: xor, tensor, normalize e outras operações
// Documentação: Seção 8.3

fn main() {
    print_string("=== State Operations ===");

    // =========================================
    // Criar Estados de Teste
    // =========================================
    let s1 = state_neutral();
    let s2 = state_neutral();

    // Modificar s2 para diferenciação
    let s2 = state_set_layer(s2, 0, bytesil_new(10, 4));
    let s2 = state_set_layer(s2, 1, bytesil_new(12, 8));

    // =========================================
    // XOR de Estados (state_xor)
    // =========================================
    print_string("--- state_xor ---");

    // XOR combina informação de dois estados
    let xor_result = state_xor(s1, s2);

    print_string("s1 XOR s2 created");
    print_string("Result layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(xor_result, 0)));

    // XOR propriedades
    // s XOR s = vacuum
    let self_xor = state_xor(s1, s1);
    print_string("s1 XOR s1 layer 0 magnitude (should be ~0):");
    print_float(bytesil_magnitude(state_get_layer(self_xor, 0)));

    // s XOR vacuum = s
    let vacuum = state_vacuum();
    let xor_vacuum = state_xor(s1, vacuum);
    print_string("s1 XOR vacuum = s1 (layer 0 magnitude):");
    print_float(bytesil_magnitude(state_get_layer(xor_vacuum, 0)));

    // =========================================
    // Produto Tensorial (state_tensor)
    // =========================================
    print_string("--- state_tensor ---");

    // Produto tensorial de estados
    let tensor_result = state_tensor(s1, s2);

    print_string("s1 TENSOR s2 created");
    print_string("Result layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(tensor_result, 0)));

    // =========================================
    // Normalização (state_normalize)
    // =========================================
    print_string("--- state_normalize ---");

    // Criar estado com magnitudes variadas
    let unnorm = state_vacuum();
    let unnorm = state_set_layer(unnorm, 0, bytesil_new(15, 0));
    let unnorm = state_set_layer(unnorm, 1, bytesil_new(10, 0));
    let unnorm = state_set_layer(unnorm, 2, bytesil_new(5, 0));

    let normalized = state_normalize(unnorm);

    print_string("Before normalization:");
    print_string("  Layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(unnorm, 0)));
    print_string("  Layer 1 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(unnorm, 1)));

    print_string("After normalization:");
    print_string("  Layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(normalized, 0)));
    print_string("  Layer 1 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(normalized, 1)));

    // =========================================
    // Projeção (state_project)
    // =========================================
    print_string("--- state_project ---");

    // Projetar estado em grupo de camadas
    let projected = state_project(s1, 0);  // Grupo de percepção

    print_string("Projected state (group 0):");
    print_string("  Layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(projected, 0)));

    // =========================================
    // Colapso (state_collapse_xor, state_collapse_sum)
    // =========================================
    print_string("--- state_collapse ---");

    // Colapsar todas as camadas em um ByteSil via XOR
    let collapse_xor = state_collapse_xor(s1);
    print_string("Collapse via XOR magnitude:");
    print_float(bytesil_magnitude(collapse_xor));

    // Colapsar via soma
    let collapse_sum = state_collapse_sum(s1);
    print_string("Collapse via SUM magnitude:");
    print_float(bytesil_magnitude(collapse_sum));

    // =========================================
    // Comparação de Estados (state_equals)
    // =========================================
    print_string("--- state_equals ---");

    let a = state_neutral();
    let b = state_neutral();
    let c = state_vacuum();

    let eq_ab = state_equals(a, b);
    if eq_ab {
        print_string("a equals b: true");
    }

    let eq_ac = state_equals(a, c);
    if eq_ac {
        print_string("a equals c: true");
    } else {
        print_string("a equals c: false");
    }

    // =========================================
    // Contagem de Camadas
    // =========================================
    print_string("--- Layer Counting ---");

    let mixed = state_vacuum();
    let mixed = state_set_layer(mixed, 0, bytesil_new(5, 0));
    let mixed = state_set_layer(mixed, 5, bytesil_new(10, 0));
    let mixed = state_set_layer(mixed, 10, bytesil_new(15, 0));

    let active = state_count_active_layers(mixed);
    print_string("Active layers in mixed state:");
    print_int(active);

    let null_count = state_count_null_layers(mixed);
    print_string("Null layers in mixed state:");
    print_int(null_count);

    // =========================================
    // Hash de Estado (state_hash)
    // =========================================
    print_string("--- state_hash ---");

    let hash_s1 = state_hash(s1);
    print_string("Hash of s1:");
    print_int(hash_s1);

    let hash_s2 = state_hash(s2);
    print_string("Hash of s2:");
    print_int(hash_s2);

    // Mesmo estado = mesmo hash
    let hash_s1_copy = state_hash(state_neutral());
    print_string("Hash of another neutral state:");
    print_int(hash_s1_copy);
}
