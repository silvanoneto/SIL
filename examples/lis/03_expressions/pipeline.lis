// LIS Example: Operador Pipeline
// Demonstra: |> (pipe) para encadeamento de transformações
// Documentação: Seção 6.11

// =========================================
// Transforms para uso no Pipeline
// =========================================

transform double_state(s: State) -> State {
    return transform_magnitude_scale(s, 2.0);
}

transform half_state(s: State) -> State {
    return transform_magnitude_scale(s, 0.5);
}

transform shift_phase(s: State) -> State {
    return transform_phase_shift(s, 0.785);  // pi/4
}

transform normalize(s: State) -> State {
    return state_normalize(s);
}

transform apply_relu(s: State) -> State {
    return relu_state(s);
}

// =========================================
// Funções simples para pipeline
// =========================================

fn add_ten(x: Int) -> Int {
    return x + 10;
}

fn double(x: Int) -> Int {
    return x * 2;
}

fn square(x: Int) -> Int {
    return x * x;
}

fn main() {
    print_string("=== Pipeline Operator (|>) ===");

    // =========================================
    // Pipeline Básico com State
    // =========================================
    print_string("--- State Pipeline ---");

    let input = state_neutral();

    // Encadeamento de transformações
    let result = input |> double_state |> shift_phase |> normalize;

    print_string("Pipeline: input |> double |> shift |> normalize");
    print_string("Result layer 0 magnitude:");
    print_float(bytesil_magnitude(state_get_layer(result, 0)));

    // =========================================
    // Equivalência sem Pipeline
    // =========================================
    print_string("--- Equivalent without pipeline ---");

    // O pipeline acima é equivalente a:
    let temp1 = double_state(input);
    let temp2 = shift_phase(temp1);
    let result2 = normalize(temp2);

    print_string("Nested calls result:");
    print_float(bytesil_magnitude(state_get_layer(result2, 0)));

    // =========================================
    // Pipeline Longo
    // =========================================
    print_string("--- Long Pipeline ---");

    let s = state_neutral();

    let processed = s
        |> double_state
        |> apply_relu
        |> normalize
        |> half_state
        |> shift_phase;

    print_string("5-stage pipeline complete");
    print_string("Final magnitude:");
    print_float(bytesil_magnitude(state_get_layer(processed, 0)));

    // =========================================
    // Pipeline com Funções
    // =========================================
    print_string("--- Function Pipeline ---");

    let x = 5;

    // 5 |> add_ten |> double |> square
    // = ((5 + 10) * 2)^2
    // = (15 * 2)^2
    // = 30^2
    // = 900
    let piped = x |> add_ten |> double |> square;

    print_string("5 |> (+10) |> (*2) |> (^2) =");
    print_int(piped);

    // =========================================
    // Uso Prático: Neural Network Layer
    // =========================================
    print_string("--- Practical: Neural Layer ---");

    let layer_input = state_neutral();
    let weights = state_neutral();
    let bias = state_vacuum();

    // Forward pass com pipeline
    let output = layer_input
        |> normalize
        |> apply_relu
        |> normalize;

    print_string("Neural layer forward pass complete");

    // =========================================
    // Pipeline vs Nested Calls (Legibilidade)
    // =========================================
    print_string("--- Readability Comparison ---");

    // Com pipeline: lê da esquerda para direita
    // input |> step1 |> step2 |> step3

    // Sem pipeline: lê de dentro para fora
    // step3(step2(step1(input)))

    // Pipeline é mais legível para cadeias longas
    print_string("Pipeline improves readability for chains");
}
