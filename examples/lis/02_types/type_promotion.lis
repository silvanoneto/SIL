// LIS Example: Promoção de Tipos
// Demonstra: Promoção numérica Int → Float → Complex
// Documentação: Seção 4.2

fn main() {
    // =========================================
    // Hierarquia de Promoção Numérica
    // =========================================
    //
    //    Int ────────► Float ────────► Complex
    //
    // Quando operações envolvem tipos diferentes,
    // o tipo menor é promovido para o maior.

    print_string("=== Type Promotion ===");

    // =========================================
    // Int para Float
    // =========================================

    let int_val: Int = 42;
    let float_val: Float = 3.14;

    // Int + Float → Float (int promovido)
    let result1 = int_val + float_val;

    print_string("Int + Float:");
    print_float(result1);  // 45.14

    // Int * Float → Float
    let result2 = int_val * float_val;

    print_string("Int * Float:");
    print_float(result2);

    // =========================================
    // Atribuição com Promoção
    // =========================================

    // Int atribuído a Float
    let promoted: Float = 100;  // 100 → 100.0

    print_string("Int assigned to Float:");
    print_float(promoted);

    // =========================================
    // Promoção em Chamadas de Função
    // =========================================

    // Função espera Float, recebe Int
    let sin_of_zero = sin(0);  // 0 promovido para 0.0

    print_string("sin(0) - Int promoted to Float:");
    print_float(sin_of_zero);

    // sqrt de inteiro
    let sqrt_of_4 = sqrt(4);  // 4 promovido para 4.0

    print_string("sqrt(4) - Int promoted to Float:");
    print_float(sqrt_of_4);

    // =========================================
    // Promoção em Expressões Complexas
    // =========================================

    let a: Int = 10;
    let b: Float = 2.5;
    let c: Int = 3;

    // (a + b) * c
    // a + b → Float (10.0 + 2.5 = 12.5)
    // 12.5 * c → Float (c promovido: 12.5 * 3.0 = 37.5)
    let complex_expr = (a + b) * c;

    print_string("(10 + 2.5) * 3:");
    print_float(complex_expr);

    // =========================================
    // Float para Complex (ByteSil)
    // =========================================

    // Criar ByteSil a partir de magnitude (Float implícito)
    let bs = bytesil_from_complex(1.0, 0.0);  // 1 + 0i

    print_string("Float to ByteSil conversion:");
    print_float(bytesil_magnitude(bs));

    // =========================================
    // Promoção em Comparações
    // =========================================

    let int_a: Int = 5;
    let float_b: Float = 5.0;

    // Comparação Int == Float (int promovido)
    if int_a == floor(float_b) {
        print_string("5 (Int) equals floor(5.0) (Float)");
    }

    // =========================================
    // Regras de Compatibilidade
    // =========================================
    //
    // 1. Error é compatível com tudo (recovery)
    // 2. Inteiros promovem para Float e Complex
    // 3. Complex e ByteSil são intercambiáveis
    // 4. Hardware hints devem corresponder
    // 5. Tipos Unknown são compatíveis (inferência)
    // 6. Funções compatíveis se assinaturas correspondem
    // 7. Tuplas compatíveis se elementos correspondem

    print_string("Type promotion demo complete");
}
