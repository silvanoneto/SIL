// LIS Example: Tipos de Retorno
// Demonstra: Retorno explícito, implícito e Unit
// Documentação: Seções 5.2, 7.3

// =========================================
// Retorno Explícito com Tipo
// =========================================

fn explicit_return(x: Int) -> Int {
    return x * 2;
}

fn explicit_float(x: Float) -> Float {
    return x + 1.0;
}

fn explicit_bool(x: Int) -> Bool {
    return x > 0;
}

fn explicit_string() -> String {
    return "Hello from function";
}

fn explicit_bytesil() -> ByteSil {
    return bytesil_new(8, 4);
}

fn explicit_state() -> State {
    return state_vacuum();
}

// =========================================
// Retorno Implícito (Inferido)
// =========================================

fn inferred_int(a: Int, b: Int) {
    return a + b;  // Retorno inferido como Int
}

fn inferred_from_condition(x: Int) {
    if x > 0 {
        return x;
    }
    return -x;  // Tipo inferido: Int
}

// =========================================
// Retorno Void / Unit
// =========================================

// Funções que não retornam valor (side effects apenas)
fn print_hello() {
    print_string("Hello!");
    return;
}

fn print_number(n: Int) {
    print_string("Number:");
    print_int(n);
    // return implícito (Unit)
}

fn log_message(msg: String) {
    print_string(msg);  // Use print_string for simple logging
}

// =========================================
// Múltiplos Returns (Early Return)
// =========================================

fn absolute_value(x: Int) -> Int {
    if x < 0 {
        return -x;  // Early return
    }
    return x;
}

fn find_sign(x: Int) -> Int {
    if x > 0 {
        return 1;
    }
    if x < 0 {
        return -1;
    }
    return 0;  // x == 0
}

fn validate_range(value: Int, min_val: Int, max_val: Int) -> Bool {
    if value < min_val {
        return false;  // Too small
    }
    if value > max_val {
        return false;  // Too large
    }
    return true;  // Valid
}

// =========================================
// Retorno em Loops
// =========================================

fn find_first_positive(limit: Int) -> Int {
    let i = -10;
    loop {
        if i > limit {
            return -1;  // Not found
        }
        if i > 0 {
            return i;  // Found!
        }
        let i = i + 1;
    }
    return -1;  // Unreachable, but satisfies type checker
}

fn factorial(n: Int) -> Int {
    if n <= 1 {
        return 1;
    }

    let result = 1;
    let i = 2;
    loop {
        if i > n {
            return result;
        }
        let result = result * i;
        let i = i + 1;
    }
    return result;
}

// =========================================
// Retorno de Expressões Complexas
// =========================================

fn max_of_three(a: Int, b: Int, c: Int) -> Int {
    if a >= b && a >= c {
        return a;
    }
    if b >= a && b >= c {
        return b;
    }
    return c;
}

fn compute_and_return(x: Int) -> Int {
    let temp = x * 2;
    let temp = temp + 10;
    let temp = temp / 2;
    return temp;  // Return computed value
}

fn main() {
    print_string("=== Return Types Demo ===");

    // Explicit returns
    let r1 = explicit_return(5);
    print_string("explicit_return(5) =");
    print_int(r1);

    let r2 = explicit_float(2.5);
    print_string("explicit_float(2.5) =");
    print_float(r2);

    let r3 = explicit_bool(10);
    if r3 {
        print_string("explicit_bool(10) = true");
    }

    // Void functions
    print_hello();
    print_number(42);

    // Multiple returns
    let abs_val = absolute_value(-15);
    print_string("absolute_value(-15) =");
    print_int(abs_val);

    let sign = find_sign(-100);
    print_string("find_sign(-100) =");
    print_int(sign);

    // Complex returns
    let max_val = max_of_three(10, 25, 15);
    print_string("max_of_three(10, 25, 15) =");
    print_int(max_val);

    let fact = factorial(6);
    print_string("factorial(6) =");
    print_int(fact);
}
