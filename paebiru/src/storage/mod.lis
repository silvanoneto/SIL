// Paebiru ML Library - Storage Module
// Distributed model storage and checkpointing

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Storage Backend Types
// =============================================================================

pub fn STORAGE_LOCAL() -> Int { return 0; }
pub fn STORAGE_RELATIONAL() -> Int { return 1; }
pub fn STORAGE_DOCUMENT() -> Int { return 2; }
pub fn STORAGE_GRAPH() -> Int { return 3; }
pub fn STORAGE_VECTOR() -> Int { return 4; }

// =============================================================================
// Model Checkpoint
// =============================================================================

// Checkpoint state layout:
// Layer 0: version number (normalized)
// Layer 1: epoch (normalized)
// Layer 2: loss value
// Layer 3: accuracy
// Layer 4: timestamp (normalized)
// Layer 5-15: metadata

// Create checkpoint metadata
pub fn checkpoint_create(version: Int, epoch: Int, loss: Float, accuracy: Float, timestamp: Float) -> State {
    let ckpt = state_vacuum();

    let ckpt = state_set_layer(ckpt, 0, bs_from_mag_clamped(float_from_int(version % 256) / 256.0));
    let ckpt = state_set_layer(ckpt, 1, bs_from_mag_clamped(float_from_int(epoch % 1000) / 1000.0));
    let ckpt = state_set_layer(ckpt, 2, bs_from_mag_clamped(clamp_float(loss, 0.0, 10.0) / 10.0));
    let ckpt = state_set_layer(ckpt, 3, bs_from_mag_clamped(clamp_float(accuracy, 0.0, 1.0)));
    let ckpt = state_set_layer(ckpt, 4, bs_from_mag_clamped(timestamp / 1e12));

    return ckpt;
}

// Extract checkpoint fields
pub fn ckpt_version(ckpt: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(ckpt, 0)) * 256.0);
}

pub fn ckpt_epoch(ckpt: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(ckpt, 1)) * 1000.0);
}

pub fn ckpt_loss(ckpt: State) -> Float {
    return bs_mag(state_get_layer(ckpt, 2)) * 10.0;
}

pub fn ckpt_accuracy(ckpt: State) -> Float {
    return bs_mag(state_get_layer(ckpt, 3));
}

pub fn ckpt_timestamp(ckpt: State) -> Float {
    return bs_mag(state_get_layer(ckpt, 4)) * 1e12;
}

// =============================================================================
// Model Sharding
// =============================================================================

// Shard info state layout:
// Layer 0: shard index
// Layer 1: total shards
// Layer 2: checksum (partial)
// Layer 3: size (normalized)

// Create shard info
pub fn shard_create(index: Int, total: Int, checksum: Int, size_mb: Float) -> State {
    let shard = state_vacuum();

    let shard = state_set_layer(shard, 0, bs_from_mag_clamped(float_from_int(index) / 256.0));
    let shard = state_set_layer(shard, 1, bs_from_mag_clamped(float_from_int(total) / 256.0));
    let shard = state_set_layer(shard, 2, bs_from_mag_clamped(float_from_int(checksum % 65536) / 65536.0));
    let shard = state_set_layer(shard, 3, bs_from_mag_clamped(size_mb / 10000.0));

    return shard;
}

// Extract shard info
pub fn shard_index(shard: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(shard, 0)) * 256.0);
}

pub fn shard_total(shard: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(shard, 1)) * 256.0);
}

pub fn shard_checksum(shard: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(shard, 2)) * 65536.0);
}

pub fn shard_size_mb(shard: State) -> Float {
    return bs_mag(state_get_layer(shard, 3)) * 10000.0;
}

// =============================================================================
// Distributed Hash Table (DHT)
// =============================================================================

// Compute DHT node for key
pub fn dht_node(key_hash: Int, num_nodes: Int) -> Int {
    return key_hash % num_nodes;
}

// Compute replication nodes (returns primary and two replicas)
pub fn dht_replicas(key_hash: Int, num_nodes: Int, replication_factor: Int) -> Int {
    let primary = key_hash % num_nodes;
    // Would return array in full implementation
    return primary;
}

// =============================================================================
// Storage Record
// =============================================================================

// Storage record layout:
// Layer 0: record type
// Layer 1: key hash (partial)
// Layer 2: value hash (partial)
// Layer 3: ttl (normalized)
// Layer 4: created_at
// Layer 5: updated_at
// Layers 6-15: value data

// Record types
pub fn RECORD_MODEL() -> Int { return 0; }
pub fn RECORD_WEIGHTS() -> Int { return 1; }
pub fn RECORD_CONFIG() -> Int { return 2; }
pub fn RECORD_METRICS() -> Int { return 3; }

// Create storage record
pub fn record_create(record_type: Int, key_hash: Int, ttl_seconds: Float) -> State {
    let record = state_vacuum();

    let record = state_set_layer(record, 0, bs_from_mag_clamped(float_from_int(record_type) / 8.0));
    let record = state_set_layer(record, 1, bs_from_mag_clamped(float_from_int(key_hash % 65536) / 65536.0));
    let record = state_set_layer(record, 3, bs_from_mag_clamped(ttl_seconds / 86400.0));  // Normalize to days

    return record;
}

// Set record value
pub fn record_set_value(record: State, value: State) -> State {
    let result = record;

    // Compute value hash
    let vh = state_hash(value);
    let result = state_set_layer(result, 2, bs_from_mag_clamped(float_from_int(vh % 65536) / 65536.0));

    // Copy first 10 layers of value to layers 6-15
    let result = state_set_layer(result, 6, state_get_layer(value, 0));
    let result = state_set_layer(result, 7, state_get_layer(value, 1));
    let result = state_set_layer(result, 8, state_get_layer(value, 2));
    let result = state_set_layer(result, 9, state_get_layer(value, 3));
    let result = state_set_layer(result, 10, state_get_layer(value, 4));
    let result = state_set_layer(result, 11, state_get_layer(value, 5));
    let result = state_set_layer(result, 12, state_get_layer(value, 6));
    let result = state_set_layer(result, 13, state_get_layer(value, 7));
    let result = state_set_layer(result, 14, state_get_layer(value, 8));
    let result = state_set_layer(result, 15, state_get_layer(value, 9));

    return result;
}

// Get record value
pub fn record_get_value(record: State) -> State {
    let value = state_vacuum();

    let value = state_set_layer(value, 0, state_get_layer(record, 6));
    let value = state_set_layer(value, 1, state_get_layer(record, 7));
    let value = state_set_layer(value, 2, state_get_layer(record, 8));
    let value = state_set_layer(value, 3, state_get_layer(record, 9));
    let value = state_set_layer(value, 4, state_get_layer(record, 10));
    let value = state_set_layer(value, 5, state_get_layer(record, 11));
    let value = state_set_layer(value, 6, state_get_layer(record, 12));
    let value = state_set_layer(value, 7, state_get_layer(record, 13));
    let value = state_set_layer(value, 8, state_get_layer(record, 14));
    let value = state_set_layer(value, 9, state_get_layer(record, 15));

    return value;
}

// Extract record fields
pub fn record_type(record: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(record, 0)) * 8.0);
}

pub fn record_key_hash(record: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(record, 1)) * 65536.0);
}

pub fn record_value_hash(record: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(record, 2)) * 65536.0);
}

pub fn record_ttl_seconds(record: State) -> Float {
    return bs_mag(state_get_layer(record, 3)) * 86400.0;
}

// =============================================================================
// Version Control
// =============================================================================

// Compare two versions, returns -1, 0, or 1
pub fn version_compare(v1: Int, v2: Int) -> Int {
    if v1 < v2 { return -1; }
    if v1 > v2 { return 1; }
    return 0;
}

// Increment version
pub fn version_increment(current: Int) -> Int {
    return current + 1;
}

