// Paebiru ML Library - Loss Functions
// Funcoes de perda para treinamento de redes neurais

use core::bytesil::{bs_mag, EPSILON};
use core::state::{st_dot_mag, st_sum_mag_sq};
use core::linalg::{norm_l2};

// =============================================================================
// Mean Squared Error
// =============================================================================

pub fn mse(pred: State, target: State) -> Float {
    let d0 = bs_mag(state_get_layer(pred, 0)) - bs_mag(state_get_layer(target, 0));
    let d1 = bs_mag(state_get_layer(pred, 1)) - bs_mag(state_get_layer(target, 1));
    let d2 = bs_mag(state_get_layer(pred, 2)) - bs_mag(state_get_layer(target, 2));
    let d3 = bs_mag(state_get_layer(pred, 3)) - bs_mag(state_get_layer(target, 3));
    let d4 = bs_mag(state_get_layer(pred, 4)) - bs_mag(state_get_layer(target, 4));
    let d5 = bs_mag(state_get_layer(pred, 5)) - bs_mag(state_get_layer(target, 5));
    let d6 = bs_mag(state_get_layer(pred, 6)) - bs_mag(state_get_layer(target, 6));
    let d7 = bs_mag(state_get_layer(pred, 7)) - bs_mag(state_get_layer(target, 7));
    let d8 = bs_mag(state_get_layer(pred, 8)) - bs_mag(state_get_layer(target, 8));
    let d9 = bs_mag(state_get_layer(pred, 9)) - bs_mag(state_get_layer(target, 9));
    let d10 = bs_mag(state_get_layer(pred, 10)) - bs_mag(state_get_layer(target, 10));
    let d11 = bs_mag(state_get_layer(pred, 11)) - bs_mag(state_get_layer(target, 11));
    let d12 = bs_mag(state_get_layer(pred, 12)) - bs_mag(state_get_layer(target, 12));
    let d13 = bs_mag(state_get_layer(pred, 13)) - bs_mag(state_get_layer(target, 13));
    let d14 = bs_mag(state_get_layer(pred, 14)) - bs_mag(state_get_layer(target, 14));
    let d15 = bs_mag(state_get_layer(pred, 15)) - bs_mag(state_get_layer(target, 15));
    let sum = d0*d0 + d1*d1 + d2*d2 + d3*d3 + d4*d4 + d5*d5 + d6*d6 + d7*d7;
    let sum = sum + d8*d8 + d9*d9 + d10*d10 + d11*d11 + d12*d12 + d13*d13 + d14*d14 + d15*d15;
    return sum / 16.0;
}

pub fn rmse(pred: State, target: State) -> Float {
    return sqrt(mse(pred, target));
}

// =============================================================================
// Mean Absolute Error
// =============================================================================

pub fn mae(pred: State, target: State) -> Float {
    let sum = 0.0;
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 0)) - bs_mag(state_get_layer(target, 0)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 1)) - bs_mag(state_get_layer(target, 1)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 2)) - bs_mag(state_get_layer(target, 2)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 3)) - bs_mag(state_get_layer(target, 3)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 4)) - bs_mag(state_get_layer(target, 4)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 5)) - bs_mag(state_get_layer(target, 5)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 6)) - bs_mag(state_get_layer(target, 6)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 7)) - bs_mag(state_get_layer(target, 7)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 8)) - bs_mag(state_get_layer(target, 8)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 9)) - bs_mag(state_get_layer(target, 9)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 10)) - bs_mag(state_get_layer(target, 10)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 11)) - bs_mag(state_get_layer(target, 11)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 12)) - bs_mag(state_get_layer(target, 12)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 13)) - bs_mag(state_get_layer(target, 13)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 14)) - bs_mag(state_get_layer(target, 14)));
    let sum = sum + abs_float(bs_mag(state_get_layer(pred, 15)) - bs_mag(state_get_layer(target, 15)));
    return sum / 16.0;
}

// =============================================================================
// Cross Entropy
// =============================================================================

pub fn cross_entropy(pred: State, target: State) -> Float {
    let eps = EPSILON();
    let p0 = max_float(bs_mag(state_get_layer(pred, 0)), eps);
    let p1 = max_float(bs_mag(state_get_layer(pred, 1)), eps);
    let p2 = max_float(bs_mag(state_get_layer(pred, 2)), eps);
    let p3 = max_float(bs_mag(state_get_layer(pred, 3)), eps);
    let p4 = max_float(bs_mag(state_get_layer(pred, 4)), eps);
    let p5 = max_float(bs_mag(state_get_layer(pred, 5)), eps);
    let p6 = max_float(bs_mag(state_get_layer(pred, 6)), eps);
    let p7 = max_float(bs_mag(state_get_layer(pred, 7)), eps);
    let p8 = max_float(bs_mag(state_get_layer(pred, 8)), eps);
    let p9 = max_float(bs_mag(state_get_layer(pred, 9)), eps);
    let p10 = max_float(bs_mag(state_get_layer(pred, 10)), eps);
    let p11 = max_float(bs_mag(state_get_layer(pred, 11)), eps);
    let p12 = max_float(bs_mag(state_get_layer(pred, 12)), eps);
    let p13 = max_float(bs_mag(state_get_layer(pred, 13)), eps);
    let p14 = max_float(bs_mag(state_get_layer(pred, 14)), eps);
    let p15 = max_float(bs_mag(state_get_layer(pred, 15)), eps);
    let t0 = bs_mag(state_get_layer(target, 0));
    let t1 = bs_mag(state_get_layer(target, 1));
    let t2 = bs_mag(state_get_layer(target, 2));
    let t3 = bs_mag(state_get_layer(target, 3));
    let t4 = bs_mag(state_get_layer(target, 4));
    let t5 = bs_mag(state_get_layer(target, 5));
    let t6 = bs_mag(state_get_layer(target, 6));
    let t7 = bs_mag(state_get_layer(target, 7));
    let t8 = bs_mag(state_get_layer(target, 8));
    let t9 = bs_mag(state_get_layer(target, 9));
    let t10 = bs_mag(state_get_layer(target, 10));
    let t11 = bs_mag(state_get_layer(target, 11));
    let t12 = bs_mag(state_get_layer(target, 12));
    let t13 = bs_mag(state_get_layer(target, 13));
    let t14 = bs_mag(state_get_layer(target, 14));
    let t15 = bs_mag(state_get_layer(target, 15));
    let loss = t0 * ln(p0) + t1 * ln(p1) + t2 * ln(p2) + t3 * ln(p3);
    let loss = loss + t4 * ln(p4) + t5 * ln(p5) + t6 * ln(p6) + t7 * ln(p7);
    let loss = loss + t8 * ln(p8) + t9 * ln(p9) + t10 * ln(p10) + t11 * ln(p11);
    let loss = loss + t12 * ln(p12) + t13 * ln(p13) + t14 * ln(p14) + t15 * ln(p15);
    return 0.0 - loss;
}

// Binary cross entropy
pub fn bce(pred: State, target: State) -> Float {
    let eps = EPSILON();
    let sum = 0.0;
    let p0 = clamp_float(bs_mag(state_get_layer(pred, 0)), eps, 1.0 - eps);
    let t0 = bs_mag(state_get_layer(target, 0));
    let sum = sum - t0 * ln(p0) - (1.0 - t0) * ln(1.0 - p0);
    let p1 = clamp_float(bs_mag(state_get_layer(pred, 1)), eps, 1.0 - eps);
    let t1 = bs_mag(state_get_layer(target, 1));
    let sum = sum - t1 * ln(p1) - (1.0 - t1) * ln(1.0 - p1);
    let p2 = clamp_float(bs_mag(state_get_layer(pred, 2)), eps, 1.0 - eps);
    let t2 = bs_mag(state_get_layer(target, 2));
    let sum = sum - t2 * ln(p2) - (1.0 - t2) * ln(1.0 - p2);
    let p3 = clamp_float(bs_mag(state_get_layer(pred, 3)), eps, 1.0 - eps);
    let t3 = bs_mag(state_get_layer(target, 3));
    let sum = sum - t3 * ln(p3) - (1.0 - t3) * ln(1.0 - p3);
    // Continua para as 16 camadas (simplificado)
    return sum / 16.0;
}

// =============================================================================
// Cosine Loss
// =============================================================================

pub fn cosine_loss(pred: State, target: State) -> Float {
    let dot_val = st_dot_mag(pred, target);
    let np_sq = st_sum_mag_sq(pred);
    let nt_sq = st_sum_mag_sq(target);
    let denom = sqrt(np_sq) * sqrt(nt_sq);
    if denom < EPSILON() {
        return 1.0;
    }
    return 1.0 - dot_val / denom;
}

// =============================================================================
// Regularizacao
// =============================================================================

pub fn l1_regularization(weights: State, lambda: Float) -> Float {
    let sum = 0.0;
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 0)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 1)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 2)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 3)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 4)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 5)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 6)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 7)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 8)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 9)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 10)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 11)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 12)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 13)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 14)));
    let sum = sum + abs_float(bs_mag(state_get_layer(weights, 15)));
    return lambda * sum;
}

pub fn l2_regularization(weights: State, lambda: Float) -> Float {
    let sq_sum = st_sum_mag_sq(weights);
    return lambda * sq_sum;
}

// =============================================================================
// Huber Loss (robusto a outliers)
// =============================================================================

pub fn huber_loss(pred: State, target: State, delta: Float) -> Float {
    let sum = 0.0;
    let d0 = abs_float(bs_mag(state_get_layer(pred, 0)) - bs_mag(state_get_layer(target, 0)));
    if d0 <= delta {
        let sum = sum + 0.5 * d0 * d0;
    } else {
        let sum = sum + delta * (d0 - 0.5 * delta);
    }
    // Simplificado - repetir para todas as 16 camadas
    return sum / 16.0;
}
