// Paebiru ML Library - Recurrent Neural Networks
// RNN, LSTM, GRU implementations

use core::bytesil::{bs_mag, bs_from_mag_clamped};
use core::state::{st_add, st_scale, st_mul};
use core::activations::{sigmoid_state, tanh_state};

// =============================================================================
// Vanilla RNN
// =============================================================================

// RNN cell: h_t = tanh(W_h * h_{t-1} + W_x * x_t + b)
pub fn rnn_cell(x: State, h_prev: State, W_h: State, W_x: State, bias: State) -> State {
    let wh = st_mul(W_h, h_prev);
    let wx = st_mul(W_x, x);
    let pre_act = st_add(wh, wx);
    let pre_act = st_add(pre_act, bias);
    return tanh_state(pre_act);
}

// =============================================================================
// LSTM (Long Short-Term Memory)
// =============================================================================

// LSTM gates computation
// Returns: (forget_gate, input_gate, output_gate, cell_candidate)
pub fn lstm_gates(x: State, h_prev: State,
                  W_f: State, W_i: State, W_o: State, W_c: State,
                  b_f: State, b_i: State, b_o: State, b_c: State) -> State {
    // Forget gate: f = sigmoid(W_f * [h, x] + b_f)
    let hx_f = st_add(st_mul(W_f, h_prev), st_mul(W_f, x));
    let f_gate = sigmoid_state(st_add(hx_f, b_f));

    // Input gate: i = sigmoid(W_i * [h, x] + b_i)
    let hx_i = st_add(st_mul(W_i, h_prev), st_mul(W_i, x));
    let i_gate = sigmoid_state(st_add(hx_i, b_i));

    // Cell candidate: c_tilde = tanh(W_c * [h, x] + b_c)
    let hx_c = st_add(st_mul(W_c, h_prev), st_mul(W_c, x));
    let c_tilde = tanh_state(st_add(hx_c, b_c));

    // Return combined state with gates encoded
    // For simplicity, we'll return the input gate (used for cell update)
    return st_mul(i_gate, c_tilde);
}

// LSTM cell forward pass
// Returns new hidden state h_t
pub fn lstm_cell(x: State, h_prev: State, c_prev: State,
                 W_f: State, W_i: State, W_o: State, W_c: State,
                 b_f: State, b_i: State, b_o: State, b_c: State) -> State {

    // Forget gate
    let hx_f = st_add(st_mul(W_f, h_prev), st_mul(W_f, x));
    let f_gate = sigmoid_state(st_add(hx_f, b_f));

    // Input gate
    let hx_i = st_add(st_mul(W_i, h_prev), st_mul(W_i, x));
    let i_gate = sigmoid_state(st_add(hx_i, b_i));

    // Cell candidate
    let hx_c = st_add(st_mul(W_c, h_prev), st_mul(W_c, x));
    let c_tilde = tanh_state(st_add(hx_c, b_c));

    // New cell state: c_t = f * c_{t-1} + i * c_tilde
    let fc = st_mul(f_gate, c_prev);
    let ic = st_mul(i_gate, c_tilde);
    let c_new = st_add(fc, ic);

    // Output gate
    let hx_o = st_add(st_mul(W_o, h_prev), st_mul(W_o, x));
    let o_gate = sigmoid_state(st_add(hx_o, b_o));

    // New hidden state: h_t = o * tanh(c_t)
    let c_tanh = tanh_state(c_new);
    return st_mul(o_gate, c_tanh);
}

// Get new cell state (companion to lstm_cell)
pub fn lstm_cell_state(x: State, h_prev: State, c_prev: State,
                       W_f: State, W_i: State, W_c: State,
                       b_f: State, b_i: State, b_c: State) -> State {

    // Forget gate
    let hx_f = st_add(st_mul(W_f, h_prev), st_mul(W_f, x));
    let f_gate = sigmoid_state(st_add(hx_f, b_f));

    // Input gate
    let hx_i = st_add(st_mul(W_i, h_prev), st_mul(W_i, x));
    let i_gate = sigmoid_state(st_add(hx_i, b_i));

    // Cell candidate
    let hx_c = st_add(st_mul(W_c, h_prev), st_mul(W_c, x));
    let c_tilde = tanh_state(st_add(hx_c, b_c));

    // New cell state
    let fc = st_mul(f_gate, c_prev);
    let ic = st_mul(i_gate, c_tilde);
    return st_add(fc, ic);
}

// =============================================================================
// GRU (Gated Recurrent Unit)
// =============================================================================

// GRU cell forward pass
// r = reset gate, z = update gate
pub fn gru_cell(x: State, h_prev: State,
                W_r: State, W_z: State, W_h: State,
                b_r: State, b_z: State, b_h: State) -> State {

    // Reset gate: r = sigmoid(W_r * [h, x] + b_r)
    let hx_r = st_add(st_mul(W_r, h_prev), st_mul(W_r, x));
    let r_gate = sigmoid_state(st_add(hx_r, b_r));

    // Update gate: z = sigmoid(W_z * [h, x] + b_z)
    let hx_z = st_add(st_mul(W_z, h_prev), st_mul(W_z, x));
    let z_gate = sigmoid_state(st_add(hx_z, b_z));

    // Candidate hidden: h_tilde = tanh(W_h * [r*h, x] + b_h)
    let rh = st_mul(r_gate, h_prev);
    let rhx = st_add(st_mul(W_h, rh), st_mul(W_h, x));
    let h_tilde = tanh_state(st_add(rhx, b_h));

    // New hidden: h_t = (1 - z) * h_{t-1} + z * h_tilde
    let one_minus_z = compute_one_minus(z_gate);
    let zh = st_mul(one_minus_z, h_prev);
    let z_htilde = st_mul(z_gate, h_tilde);
    return st_add(zh, z_htilde);
}

// Helper: compute (1 - x) element-wise
fn compute_one_minus(x: State) -> State {
    let result = state_vacuum();

    let m0 = 1.0 - bs_mag(state_get_layer(x, 0));
    let result = state_set_layer(result, 0, bs_from_mag_clamped(m0));

    let m1 = 1.0 - bs_mag(state_get_layer(x, 1));
    let result = state_set_layer(result, 1, bs_from_mag_clamped(m1));

    let m2 = 1.0 - bs_mag(state_get_layer(x, 2));
    let result = state_set_layer(result, 2, bs_from_mag_clamped(m2));

    let m3 = 1.0 - bs_mag(state_get_layer(x, 3));
    let result = state_set_layer(result, 3, bs_from_mag_clamped(m3));

    let m4 = 1.0 - bs_mag(state_get_layer(x, 4));
    let result = state_set_layer(result, 4, bs_from_mag_clamped(m4));

    let m5 = 1.0 - bs_mag(state_get_layer(x, 5));
    let result = state_set_layer(result, 5, bs_from_mag_clamped(m5));

    let m6 = 1.0 - bs_mag(state_get_layer(x, 6));
    let result = state_set_layer(result, 6, bs_from_mag_clamped(m6));

    let m7 = 1.0 - bs_mag(state_get_layer(x, 7));
    let result = state_set_layer(result, 7, bs_from_mag_clamped(m7));

    let m8 = 1.0 - bs_mag(state_get_layer(x, 8));
    let result = state_set_layer(result, 8, bs_from_mag_clamped(m8));

    let m9 = 1.0 - bs_mag(state_get_layer(x, 9));
    let result = state_set_layer(result, 9, bs_from_mag_clamped(m9));

    let m10 = 1.0 - bs_mag(state_get_layer(x, 10));
    let result = state_set_layer(result, 10, bs_from_mag_clamped(m10));

    let m11 = 1.0 - bs_mag(state_get_layer(x, 11));
    let result = state_set_layer(result, 11, bs_from_mag_clamped(m11));

    let m12 = 1.0 - bs_mag(state_get_layer(x, 12));
    let result = state_set_layer(result, 12, bs_from_mag_clamped(m12));

    let m13 = 1.0 - bs_mag(state_get_layer(x, 13));
    let result = state_set_layer(result, 13, bs_from_mag_clamped(m13));

    let m14 = 1.0 - bs_mag(state_get_layer(x, 14));
    let result = state_set_layer(result, 14, bs_from_mag_clamped(m14));

    let m15 = 1.0 - bs_mag(state_get_layer(x, 15));
    let result = state_set_layer(result, 15, bs_from_mag_clamped(m15));

    return result;
}

// =============================================================================
// Initialization
// =============================================================================

// Initialize RNN hidden state
pub fn init_rnn_hidden() -> State {
    return state_vacuum();
}

// Initialize LSTM hidden and cell states
pub fn init_lstm_hidden() -> State {
    return state_vacuum();
}

pub fn init_lstm_cell() -> State {
    return state_vacuum();
}

// Initialize GRU hidden state
pub fn init_gru_hidden() -> State {
    return state_vacuum();
}

