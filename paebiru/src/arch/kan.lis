// Paebiru ML Library - Kolmogorov-Arnold Networks
// KAN: Learnable activation functions for interpretability

use core::bytesil::{bs_mag, bs_from_mag_clamped};
use core::state::{st_add, st_scale};

// =============================================================================
// B-Spline Basis Functions
// =============================================================================

// Evaluate B-spline basis function of degree 0
// Returns 1 if t is in [knot_i, knot_i+1), else 0
pub fn bspline_basis_0(t: Float, knot_i: Float, knot_i1: Float) -> Float {
    if t >= knot_i {
        if t < knot_i1 {
            return 1.0;
        }
    }
    return 0.0;
}

// Evaluate B-spline basis function of degree 1 (linear)
pub fn bspline_basis_1(t: Float, k0: Float, k1: Float, k2: Float) -> Float {
    let b0 = bspline_basis_0(t, k0, k1);
    let b1 = bspline_basis_0(t, k1, k2);

    let denom0 = k1 - k0;
    let denom1 = k2 - k1;

    let term0 = 0.0;
    let term1 = 0.0;

    if denom0 > 0.0001 {
        let term0 = ((t - k0) / denom0) * b0;
    }
    if denom1 > 0.0001 {
        let term1 = ((k2 - t) / denom1) * b1;
    }

    return term0 + term1;
}

// =============================================================================
// KAN Layer Functions
// =============================================================================

// KAN layer forward pass (simplified for 16-dim State)
// Uses learnable spline functions instead of fixed activations
// control_points: State with spline control point magnitudes
pub fn kan_forward(input: State, control_points: State, grid_min: Float, grid_max: Float) -> State {
    let result = state_vacuum();
    let grid_range = grid_max - grid_min;

    // For each layer, compute spline interpolation
    let m0 = bs_mag(state_get_layer(input, 0));
    let t0 = (m0 - grid_min) / grid_range;
    let c0 = bs_mag(state_get_layer(control_points, 0));
    let v0 = m0 * c0;  // Simplified: scale by control point
    let result = state_set_layer(result, 0, bs_from_mag_clamped(v0));

    let m1 = bs_mag(state_get_layer(input, 1));
    let c1 = bs_mag(state_get_layer(control_points, 1));
    let v1 = m1 * c1;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(v1));

    let m2 = bs_mag(state_get_layer(input, 2));
    let c2 = bs_mag(state_get_layer(control_points, 2));
    let v2 = m2 * c2;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(v2));

    let m3 = bs_mag(state_get_layer(input, 3));
    let c3 = bs_mag(state_get_layer(control_points, 3));
    let v3 = m3 * c3;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(v3));

    let m4 = bs_mag(state_get_layer(input, 4));
    let c4 = bs_mag(state_get_layer(control_points, 4));
    let v4 = m4 * c4;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(v4));

    let m5 = bs_mag(state_get_layer(input, 5));
    let c5 = bs_mag(state_get_layer(control_points, 5));
    let v5 = m5 * c5;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(v5));

    let m6 = bs_mag(state_get_layer(input, 6));
    let c6 = bs_mag(state_get_layer(control_points, 6));
    let v6 = m6 * c6;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(v6));

    let m7 = bs_mag(state_get_layer(input, 7));
    let c7 = bs_mag(state_get_layer(control_points, 7));
    let v7 = m7 * c7;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(v7));

    let m8 = bs_mag(state_get_layer(input, 8));
    let c8 = bs_mag(state_get_layer(control_points, 8));
    let v8 = m8 * c8;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(v8));

    let m9 = bs_mag(state_get_layer(input, 9));
    let c9 = bs_mag(state_get_layer(control_points, 9));
    let v9 = m9 * c9;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(v9));

    let m10 = bs_mag(state_get_layer(input, 10));
    let c10 = bs_mag(state_get_layer(control_points, 10));
    let v10 = m10 * c10;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(v10));

    let m11 = bs_mag(state_get_layer(input, 11));
    let c11 = bs_mag(state_get_layer(control_points, 11));
    let v11 = m11 * c11;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(v11));

    let m12 = bs_mag(state_get_layer(input, 12));
    let c12 = bs_mag(state_get_layer(control_points, 12));
    let v12 = m12 * c12;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(v12));

    let m13 = bs_mag(state_get_layer(input, 13));
    let c13 = bs_mag(state_get_layer(control_points, 13));
    let v13 = m13 * c13;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(v13));

    let m14 = bs_mag(state_get_layer(input, 14));
    let c14 = bs_mag(state_get_layer(control_points, 14));
    let v14 = m14 * c14;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(v14));

    let m15 = bs_mag(state_get_layer(input, 15));
    let c15 = bs_mag(state_get_layer(control_points, 15));
    let v15 = m15 * c15;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(v15));

    return result;
}

// Initialize KAN control points with small values
pub fn init_kan_control_points(seed: Float) -> State {
    let result = state_vacuum();
    let base = seed - floor(seed / 16.0) * 16.0;

    let c0 = 0.5 + (base / 32.0);
    let result = state_set_layer(result, 0, bs_from_mag_clamped(c0));

    let c1 = 0.5 + ((base + 1.0) / 32.0);
    let result = state_set_layer(result, 1, bs_from_mag_clamped(c1));

    let c2 = 0.5 + ((base + 2.0) / 32.0);
    let result = state_set_layer(result, 2, bs_from_mag_clamped(c2));

    let c3 = 0.5 + ((base + 3.0) / 32.0);
    let result = state_set_layer(result, 3, bs_from_mag_clamped(c3));

    let c4 = 0.5 + ((base + 4.0) / 32.0);
    let result = state_set_layer(result, 4, bs_from_mag_clamped(c4));

    let c5 = 0.5 + ((base + 5.0) / 32.0);
    let result = state_set_layer(result, 5, bs_from_mag_clamped(c5));

    let c6 = 0.5 + ((base + 6.0) / 32.0);
    let result = state_set_layer(result, 6, bs_from_mag_clamped(c6));

    let c7 = 0.5 + ((base + 7.0) / 32.0);
    let result = state_set_layer(result, 7, bs_from_mag_clamped(c7));

    let c8 = 0.5 + ((base + 8.0) / 32.0);
    let result = state_set_layer(result, 8, bs_from_mag_clamped(c8));

    let c9 = 0.5 + ((base + 9.0) / 32.0);
    let result = state_set_layer(result, 9, bs_from_mag_clamped(c9));

    let c10 = 0.5 + ((base + 10.0) / 32.0);
    let result = state_set_layer(result, 10, bs_from_mag_clamped(c10));

    let c11 = 0.5 + ((base + 11.0) / 32.0);
    let result = state_set_layer(result, 11, bs_from_mag_clamped(c11));

    let c12 = 0.5 + ((base + 12.0) / 32.0);
    let result = state_set_layer(result, 12, bs_from_mag_clamped(c12));

    let c13 = 0.5 + ((base + 13.0) / 32.0);
    let result = state_set_layer(result, 13, bs_from_mag_clamped(c13));

    let c14 = 0.5 + ((base + 14.0) / 32.0);
    let result = state_set_layer(result, 14, bs_from_mag_clamped(c14));

    let c15 = 0.5 + ((base + 15.0) / 32.0);
    let result = state_set_layer(result, 15, bs_from_mag_clamped(c15));

    return result;
}

