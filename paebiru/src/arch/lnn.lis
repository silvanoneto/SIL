// Paebiru ML Library - Liquid Neural Networks
// LNN: Continuous-time dynamical systems for temporal learning

use core::bytesil::{bs_mag, bs_from_mag_clamped};
use core::state::{st_add, st_scale, st_mul};
use core::activations::{sigmoid_state, tanh_state};

// =============================================================================
// Liquid Time-Constant (LTC) Cell
// =============================================================================

// LTC dynamics: tau * dx/dt = -x + f(x, I)
// Discretized: x_new = x + (dt/tau) * (-x + activation(W*x + U*I + b))
pub fn ltc_step(x: State, input: State, weights: State, input_weights: State,
                bias: State, tau: Float, dt: Float) -> State {
    // Compute: W*x + U*I + b
    let wx = st_mul(weights, x);
    let ui = st_mul(input_weights, input);
    let pre_act = st_add(wx, ui);
    let pre_act = st_add(pre_act, bias);

    // Apply tanh activation
    let f_out = tanh_state(pre_act);

    // Compute derivative: (-x + f_out)
    let neg_x = st_scale(x, -1.0);
    let dx = st_add(neg_x, f_out);

    // Update: x + (dt/tau) * dx
    let step_size = dt / tau;
    let delta = st_scale(dx, step_size);
    return st_add(x, delta);
}

// =============================================================================
// Neural ODE Step
// =============================================================================

// Simple Euler step for neural ODE
// dx/dt = f(x, t) where f is a neural network
pub fn neural_ode_euler(x: State, dx_dt: State, dt: Float) -> State {
    let delta = st_scale(dx_dt, dt);
    return st_add(x, delta);
}

// Runge-Kutta 2nd order (midpoint method)
pub fn neural_ode_rk2(x: State, f_x: State, f_mid: State, dt: Float) -> State {
    // k1 = f(x)
    // k2 = f(x + dt/2 * k1)
    // x_new = x + dt * k2
    let delta = st_scale(f_mid, dt);
    return st_add(x, delta);
}

// =============================================================================
// Continuous-Time Recurrent Cell
// =============================================================================

// CT-RNN: Continuous-time RNN with learned time constants
pub fn ctrnn_step(h: State, x: State, W_h: State, W_x: State, tau: State, dt: Float) -> State {
    let result = state_vacuum();

    // For each dimension: h_new = h + (dt/tau_i) * (-h + tanh(W_h*h + W_x*x))
    let wh = st_mul(W_h, h);
    let wx = st_mul(W_x, x);
    let pre_act = st_add(wh, wx);
    let f_out = tanh_state(pre_act);

    let m0 = bs_mag(state_get_layer(h, 0));
    let f0 = bs_mag(state_get_layer(f_out, 0));
    let t0 = bs_mag(state_get_layer(tau, 0));
    let dx0 = (0.0 - m0) + f0;
    let h_new0 = m0 + (dt / t0) * dx0;
    let result = state_set_layer(result, 0, bs_from_mag_clamped(h_new0));

    let m1 = bs_mag(state_get_layer(h, 1));
    let f1 = bs_mag(state_get_layer(f_out, 1));
    let t1 = bs_mag(state_get_layer(tau, 1));
    let dx1 = (0.0 - m1) + f1;
    let h_new1 = m1 + (dt / t1) * dx1;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(h_new1));

    let m2 = bs_mag(state_get_layer(h, 2));
    let f2 = bs_mag(state_get_layer(f_out, 2));
    let t2 = bs_mag(state_get_layer(tau, 2));
    let dx2 = (0.0 - m2) + f2;
    let h_new2 = m2 + (dt / t2) * dx2;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(h_new2));

    let m3 = bs_mag(state_get_layer(h, 3));
    let f3 = bs_mag(state_get_layer(f_out, 3));
    let t3 = bs_mag(state_get_layer(tau, 3));
    let dx3 = (0.0 - m3) + f3;
    let h_new3 = m3 + (dt / t3) * dx3;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(h_new3));

    let m4 = bs_mag(state_get_layer(h, 4));
    let f4 = bs_mag(state_get_layer(f_out, 4));
    let t4 = bs_mag(state_get_layer(tau, 4));
    let dx4 = (0.0 - m4) + f4;
    let h_new4 = m4 + (dt / t4) * dx4;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(h_new4));

    let m5 = bs_mag(state_get_layer(h, 5));
    let f5 = bs_mag(state_get_layer(f_out, 5));
    let t5 = bs_mag(state_get_layer(tau, 5));
    let dx5 = (0.0 - m5) + f5;
    let h_new5 = m5 + (dt / t5) * dx5;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(h_new5));

    let m6 = bs_mag(state_get_layer(h, 6));
    let f6 = bs_mag(state_get_layer(f_out, 6));
    let t6 = bs_mag(state_get_layer(tau, 6));
    let dx6 = (0.0 - m6) + f6;
    let h_new6 = m6 + (dt / t6) * dx6;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(h_new6));

    let m7 = bs_mag(state_get_layer(h, 7));
    let f7 = bs_mag(state_get_layer(f_out, 7));
    let t7 = bs_mag(state_get_layer(tau, 7));
    let dx7 = (0.0 - m7) + f7;
    let h_new7 = m7 + (dt / t7) * dx7;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(h_new7));

    let m8 = bs_mag(state_get_layer(h, 8));
    let f8 = bs_mag(state_get_layer(f_out, 8));
    let t8 = bs_mag(state_get_layer(tau, 8));
    let dx8 = (0.0 - m8) + f8;
    let h_new8 = m8 + (dt / t8) * dx8;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(h_new8));

    let m9 = bs_mag(state_get_layer(h, 9));
    let f9 = bs_mag(state_get_layer(f_out, 9));
    let t9 = bs_mag(state_get_layer(tau, 9));
    let dx9 = (0.0 - m9) + f9;
    let h_new9 = m9 + (dt / t9) * dx9;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(h_new9));

    let m10 = bs_mag(state_get_layer(h, 10));
    let f10 = bs_mag(state_get_layer(f_out, 10));
    let t10 = bs_mag(state_get_layer(tau, 10));
    let dx10 = (0.0 - m10) + f10;
    let h_new10 = m10 + (dt / t10) * dx10;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(h_new10));

    let m11 = bs_mag(state_get_layer(h, 11));
    let f11 = bs_mag(state_get_layer(f_out, 11));
    let t11 = bs_mag(state_get_layer(tau, 11));
    let dx11 = (0.0 - m11) + f11;
    let h_new11 = m11 + (dt / t11) * dx11;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(h_new11));

    let m12 = bs_mag(state_get_layer(h, 12));
    let f12 = bs_mag(state_get_layer(f_out, 12));
    let t12 = bs_mag(state_get_layer(tau, 12));
    let dx12 = (0.0 - m12) + f12;
    let h_new12 = m12 + (dt / t12) * dx12;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(h_new12));

    let m13 = bs_mag(state_get_layer(h, 13));
    let f13 = bs_mag(state_get_layer(f_out, 13));
    let t13 = bs_mag(state_get_layer(tau, 13));
    let dx13 = (0.0 - m13) + f13;
    let h_new13 = m13 + (dt / t13) * dx13;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(h_new13));

    let m14 = bs_mag(state_get_layer(h, 14));
    let f14 = bs_mag(state_get_layer(f_out, 14));
    let t14 = bs_mag(state_get_layer(tau, 14));
    let dx14 = (0.0 - m14) + f14;
    let h_new14 = m14 + (dt / t14) * dx14;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(h_new14));

    let m15 = bs_mag(state_get_layer(h, 15));
    let f15 = bs_mag(state_get_layer(f_out, 15));
    let t15 = bs_mag(state_get_layer(tau, 15));
    let dx15 = (0.0 - m15) + f15;
    let h_new15 = m15 + (dt / t15) * dx15;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(h_new15));

    return result;
}

// =============================================================================
// Initialization
// =============================================================================

// Initialize time constants (tau) with values > 0
pub fn init_tau(base_tau: Float) -> State {
    let result = state_vacuum();
    let tau_val = bs_from_mag_clamped(base_tau);

    let result = state_set_layer(result, 0, tau_val);
    let result = state_set_layer(result, 1, tau_val);
    let result = state_set_layer(result, 2, tau_val);
    let result = state_set_layer(result, 3, tau_val);
    let result = state_set_layer(result, 4, tau_val);
    let result = state_set_layer(result, 5, tau_val);
    let result = state_set_layer(result, 6, tau_val);
    let result = state_set_layer(result, 7, tau_val);
    let result = state_set_layer(result, 8, tau_val);
    let result = state_set_layer(result, 9, tau_val);
    let result = state_set_layer(result, 10, tau_val);
    let result = state_set_layer(result, 11, tau_val);
    let result = state_set_layer(result, 12, tau_val);
    let result = state_set_layer(result, 13, tau_val);
    let result = state_set_layer(result, 14, tau_val);
    let result = state_set_layer(result, 15, tau_val);

    return result;
}

// Initialize hidden state
pub fn init_lnn_state() -> State {
    return state_vacuum();
}

