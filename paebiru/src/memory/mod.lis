// Paebiru ML Library - Memory Module
// Caching, memory pools, and tensor storage

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Cache Entry Structure
// =============================================================================

// Cache entry represented as State
// Layer 0: validity flag (1.0 = valid, 0.0 = invalid)
// Layer 1-15: data
pub fn cache_entry_valid(entry: State) -> Bool {
    let flag = bs_mag(state_get_layer(entry, 0));
    return flag > 0.5;
}

pub fn cache_entry_invalidate(entry: State) -> State {
    return state_set_layer(entry, 0, bs_from_mag_clamped(0.0));
}

pub fn cache_entry_validate(entry: State) -> State {
    return state_set_layer(entry, 0, bs_from_mag_clamped(1.0));
}

// =============================================================================
// LRU Cache Operations
// =============================================================================

// Simple cache with 4 entries
// Each entry is a State, with layer 0 as access counter

// Update access counter for LRU eviction
pub fn cache_touch(entry: State, counter: Float) -> State {
    return state_set_layer(entry, 0, bs_from_mag_clamped(counter));
}

// Find least recently used entry (lowest counter)
pub fn cache_find_lru_4(e0: State, e1: State, e2: State, e3: State) -> Int {
    let c0 = bs_mag(state_get_layer(e0, 0));
    let c1 = bs_mag(state_get_layer(e1, 0));
    let c2 = bs_mag(state_get_layer(e2, 0));
    let c3 = bs_mag(state_get_layer(e3, 0));

    let min_val = c0;
    let min_idx = 0;

    if c1 < min_val {
        let min_val = c1;
        let min_idx = 1;
    }
    if c2 < min_val {
        let min_val = c2;
        let min_idx = 2;
    }
    if c3 < min_val {
        let min_idx = 3;
    }

    return min_idx;
}

// =============================================================================
// Memory Pool Operations
// =============================================================================

// Pool status tracking
// Uses a State where each layer represents buffer availability
// 1.0 = available, 0.0 = in use

// Initialize pool with all buffers available
pub fn pool_init_16() -> State {
    let pool = state_vacuum();
    let avail = bs_from_mag_clamped(1.0);

    let pool = state_set_layer(pool, 0, avail);
    let pool = state_set_layer(pool, 1, avail);
    let pool = state_set_layer(pool, 2, avail);
    let pool = state_set_layer(pool, 3, avail);
    let pool = state_set_layer(pool, 4, avail);
    let pool = state_set_layer(pool, 5, avail);
    let pool = state_set_layer(pool, 6, avail);
    let pool = state_set_layer(pool, 7, avail);
    let pool = state_set_layer(pool, 8, avail);
    let pool = state_set_layer(pool, 9, avail);
    let pool = state_set_layer(pool, 10, avail);
    let pool = state_set_layer(pool, 11, avail);
    let pool = state_set_layer(pool, 12, avail);
    let pool = state_set_layer(pool, 13, avail);
    let pool = state_set_layer(pool, 14, avail);
    let pool = state_set_layer(pool, 15, avail);

    return pool;
}

// Allocate buffer from pool, returns index (-1 if none available)
pub fn pool_allocate(pool: State) -> Int {
    let a0 = bs_mag(state_get_layer(pool, 0));
    if a0 > 0.5 { return 0; }

    let a1 = bs_mag(state_get_layer(pool, 1));
    if a1 > 0.5 { return 1; }

    let a2 = bs_mag(state_get_layer(pool, 2));
    if a2 > 0.5 { return 2; }

    let a3 = bs_mag(state_get_layer(pool, 3));
    if a3 > 0.5 { return 3; }

    let a4 = bs_mag(state_get_layer(pool, 4));
    if a4 > 0.5 { return 4; }

    let a5 = bs_mag(state_get_layer(pool, 5));
    if a5 > 0.5 { return 5; }

    let a6 = bs_mag(state_get_layer(pool, 6));
    if a6 > 0.5 { return 6; }

    let a7 = bs_mag(state_get_layer(pool, 7));
    if a7 > 0.5 { return 7; }

    let a8 = bs_mag(state_get_layer(pool, 8));
    if a8 > 0.5 { return 8; }

    let a9 = bs_mag(state_get_layer(pool, 9));
    if a9 > 0.5 { return 9; }

    let a10 = bs_mag(state_get_layer(pool, 10));
    if a10 > 0.5 { return 10; }

    let a11 = bs_mag(state_get_layer(pool, 11));
    if a11 > 0.5 { return 11; }

    let a12 = bs_mag(state_get_layer(pool, 12));
    if a12 > 0.5 { return 12; }

    let a13 = bs_mag(state_get_layer(pool, 13));
    if a13 > 0.5 { return 13; }

    let a14 = bs_mag(state_get_layer(pool, 14));
    if a14 > 0.5 { return 14; }

    let a15 = bs_mag(state_get_layer(pool, 15));
    if a15 > 0.5 { return 15; }

    return -1;  // No available buffer
}

// Mark buffer as in use
pub fn pool_mark_used(pool: State, idx: Int) -> State {
    return state_set_layer(pool, idx, bs_from_mag_clamped(0.0));
}

// Mark buffer as available
pub fn pool_deallocate(pool: State, idx: Int) -> State {
    return state_set_layer(pool, idx, bs_from_mag_clamped(1.0));
}

// Count available buffers
pub fn pool_available_count(pool: State) -> Int {
    let count = 0;

    let a0 = bs_mag(state_get_layer(pool, 0));
    if a0 > 0.5 { let count = count + 1; }

    let a1 = bs_mag(state_get_layer(pool, 1));
    if a1 > 0.5 { let count = count + 1; }

    let a2 = bs_mag(state_get_layer(pool, 2));
    if a2 > 0.5 { let count = count + 1; }

    let a3 = bs_mag(state_get_layer(pool, 3));
    if a3 > 0.5 { let count = count + 1; }

    let a4 = bs_mag(state_get_layer(pool, 4));
    if a4 > 0.5 { let count = count + 1; }

    let a5 = bs_mag(state_get_layer(pool, 5));
    if a5 > 0.5 { let count = count + 1; }

    let a6 = bs_mag(state_get_layer(pool, 6));
    if a6 > 0.5 { let count = count + 1; }

    let a7 = bs_mag(state_get_layer(pool, 7));
    if a7 > 0.5 { let count = count + 1; }

    let a8 = bs_mag(state_get_layer(pool, 8));
    if a8 > 0.5 { let count = count + 1; }

    let a9 = bs_mag(state_get_layer(pool, 9));
    if a9 > 0.5 { let count = count + 1; }

    let a10 = bs_mag(state_get_layer(pool, 10));
    if a10 > 0.5 { let count = count + 1; }

    let a11 = bs_mag(state_get_layer(pool, 11));
    if a11 > 0.5 { let count = count + 1; }

    let a12 = bs_mag(state_get_layer(pool, 12));
    if a12 > 0.5 { let count = count + 1; }

    let a13 = bs_mag(state_get_layer(pool, 13));
    if a13 > 0.5 { let count = count + 1; }

    let a14 = bs_mag(state_get_layer(pool, 14));
    if a14 > 0.5 { let count = count + 1; }

    let a15 = bs_mag(state_get_layer(pool, 15));
    if a15 > 0.5 { let count = count + 1; }

    return count;
}

// =============================================================================
// Tensor Store Operations
// =============================================================================

// Store State with key hash
// key_hash: computed hash of key string
pub fn tensor_store_key(data: State, key_hash: Int) -> State {
    // Encode key hash into layer 0
    let hash_normalized = float_from_int(key_hash % 256) / 256.0;
    return state_set_layer(data, 0, bs_from_mag_clamped(hash_normalized));
}

// Check if stored State matches key
pub fn tensor_store_matches(stored: State, key_hash: Int) -> Bool {
    let stored_hash = bs_mag(state_get_layer(stored, 0)) * 256.0;
    let expected = float_from_int(key_hash % 256);
    let diff = abs_float(stored_hash - expected);
    return diff < 1.0;
}

// =============================================================================
// Activation Cache
// =============================================================================

// Cache for storing layer activations during inference
// Helps avoid recomputation for KV cache in transformers

// Compute simple hash for cache lookup
pub fn activation_hash(layer_idx: Int, input: State) -> Int {
    let input_hash = state_hash(input);
    return layer_idx * 1000 + (input_hash % 1000);
}

// Cache statistics tracking
// hits_state: layer 0 = hits, layer 1 = misses
pub fn cache_stats_init() -> State {
    return state_vacuum();
}

pub fn cache_stats_hit(stats: State) -> State {
    let hits = bs_mag(state_get_layer(stats, 0));
    return state_set_layer(stats, 0, bs_from_mag_clamped(hits + 1.0));
}

pub fn cache_stats_miss(stats: State) -> State {
    let misses = bs_mag(state_get_layer(stats, 1));
    return state_set_layer(stats, 1, bs_from_mag_clamped(misses + 1.0));
}

pub fn cache_hit_rate(stats: State) -> Float {
    let hits = bs_mag(state_get_layer(stats, 0));
    let misses = bs_mag(state_get_layer(stats, 1));
    let total = hits + misses;

    if total < 0.001 {
        return 0.0;
    }

    return hits / total;
}

