// Paebiru ML Library - Scaling Module
// Load balancing and resource management

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Resource Limits
// =============================================================================

// Resource limits state layout:
// Layer 0: memory_mb (normalized)
// Layer 1: cpu_cores (normalized)
// Layer 2: gpu_memory_mb (normalized)
// Layer 3: max_batch_size (normalized)
// Layer 4: timeout_ms (normalized)

// Create resource limits
pub fn limits_create(memory_mb: Float, cpu_cores: Int, gpu_memory_mb: Float) -> State {
    let limits = state_vacuum();

    let limits = state_set_layer(limits, 0, bs_from_mag_clamped(memory_mb / 65536.0));
    let limits = state_set_layer(limits, 1, bs_from_mag_clamped(float_from_int(cpu_cores) / 128.0));
    let limits = state_set_layer(limits, 2, bs_from_mag_clamped(gpu_memory_mb / 65536.0));

    return limits;
}

// Set batch and timeout limits
pub fn limits_set_inference(limits: State, max_batch: Int, timeout_ms: Float) -> State {
    let limits = state_set_layer(limits, 3, bs_from_mag_clamped(float_from_int(max_batch) / 256.0));
    let limits = state_set_layer(limits, 4, bs_from_mag_clamped(timeout_ms / 60000.0));
    return limits;
}

// Extract limits
pub fn limits_memory_mb(limits: State) -> Float {
    return bs_mag(state_get_layer(limits, 0)) * 65536.0;
}

pub fn limits_cpu_cores(limits: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(limits, 1)) * 128.0);
}

pub fn limits_gpu_memory_mb(limits: State) -> Float {
    return bs_mag(state_get_layer(limits, 2)) * 65536.0;
}

pub fn limits_max_batch(limits: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(limits, 3)) * 256.0);
}

pub fn limits_timeout_ms(limits: State) -> Float {
    return bs_mag(state_get_layer(limits, 4)) * 60000.0;
}

// =============================================================================
// Scaling Policies
// =============================================================================

pub fn POLICY_MANUAL() -> Int { return 0; }
pub fn POLICY_CPU() -> Int { return 1; }
pub fn POLICY_MEMORY() -> Int { return 2; }
pub fn POLICY_QUEUE() -> Int { return 3; }
pub fn POLICY_LATENCY() -> Int { return 4; }

// Scaling policy state layout:
// Layer 0: policy type
// Layer 1: min replicas
// Layer 2: max replicas
// Layer 3: current replicas
// Layer 4: target metric value
// Layer 5: cooldown seconds

// Create scaling policy
pub fn policy_create(policy_type: Int, min_replicas: Int, max_replicas: Int) -> State {
    let policy = state_vacuum();

    let policy = state_set_layer(policy, 0, bs_from_mag_clamped(float_from_int(policy_type) / 8.0));
    let policy = state_set_layer(policy, 1, bs_from_mag_clamped(float_from_int(min_replicas) / 64.0));
    let policy = state_set_layer(policy, 2, bs_from_mag_clamped(float_from_int(max_replicas) / 64.0));
    let policy = state_set_layer(policy, 3, bs_from_mag_clamped(float_from_int(min_replicas) / 64.0));

    return policy;
}

// Set target and cooldown
pub fn policy_set_target(policy: State, target: Float, cooldown_sec: Float) -> State {
    let policy = state_set_layer(policy, 4, bs_from_mag_clamped(clamp_float(target, 0.0, 1.0)));
    let policy = state_set_layer(policy, 5, bs_from_mag_clamped(cooldown_sec / 3600.0));
    return policy;
}

// Extract policy fields
pub fn policy_type(policy: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(policy, 0)) * 8.0);
}

pub fn policy_min_replicas(policy: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(policy, 1)) * 64.0);
}

pub fn policy_max_replicas(policy: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(policy, 2)) * 64.0);
}

pub fn policy_current_replicas(policy: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(policy, 3)) * 64.0);
}

pub fn policy_target(policy: State) -> Float {
    return bs_mag(state_get_layer(policy, 4));
}

// Update current replicas
pub fn policy_set_replicas(policy: State, replicas: Int) -> State {
    let min_r = policy_min_replicas(policy);
    let max_r = policy_max_replicas(policy);

    let r = replicas;
    if r < min_r { let r = min_r; }
    if r > max_r { let r = max_r; }

    return state_set_layer(policy, 3, bs_from_mag_clamped(float_from_int(r) / 64.0));
}

// =============================================================================
// Load Balancer
// =============================================================================

// Load balancer state (4 nodes)
// Layers 0-3: node weights
// Layers 4-7: node loads (0.0-1.0)
// Layer 8: next node index (round-robin)
// Layer 9: algorithm type

pub fn LB_ROUND_ROBIN() -> Int { return 0; }
pub fn LB_WEIGHTED() -> Int { return 1; }
pub fn LB_LEAST_LOADED() -> Int { return 2; }

// Create load balancer
pub fn lb_create(algorithm: Int) -> State {
    let lb = state_vacuum();

    // Default equal weights
    let lb = state_set_layer(lb, 0, bs_from_mag_clamped(0.25));
    let lb = state_set_layer(lb, 1, bs_from_mag_clamped(0.25));
    let lb = state_set_layer(lb, 2, bs_from_mag_clamped(0.25));
    let lb = state_set_layer(lb, 3, bs_from_mag_clamped(0.25));

    // Zero loads
    let lb = state_set_layer(lb, 4, bs_from_mag_clamped(0.0));
    let lb = state_set_layer(lb, 5, bs_from_mag_clamped(0.0));
    let lb = state_set_layer(lb, 6, bs_from_mag_clamped(0.0));
    let lb = state_set_layer(lb, 7, bs_from_mag_clamped(0.0));

    let lb = state_set_layer(lb, 8, bs_from_mag_clamped(0.0));
    let lb = state_set_layer(lb, 9, bs_from_mag_clamped(float_from_int(algorithm) / 4.0));

    return lb;
}

// Set node weight
pub fn lb_set_weight(lb: State, node: Int, weight: Float) -> State {
    if node < 0 { return lb; }
    if node > 3 { return lb; }
    return state_set_layer(lb, node, bs_from_mag_clamped(weight));
}

// Update node load
pub fn lb_set_load(lb: State, node: Int, load: Float) -> State {
    if node < 0 { return lb; }
    if node > 3 { return lb; }
    let layer = node + 4;
    return state_set_layer(lb, layer, bs_from_mag_clamped(clamp_float(load, 0.0, 1.0)));
}

// Get node load
pub fn lb_get_load(lb: State, node: Int) -> Float {
    if node < 0 { return 0.0; }
    if node > 3 { return 0.0; }
    let layer = node + 4;
    return bs_mag(state_get_layer(lb, layer));
}

// Select next node (round-robin)
pub fn lb_next_round_robin(lb: State) -> Int {
    let current = int_from_float(bs_mag(state_get_layer(lb, 8)) * 4.0);
    return current;
}

// Advance round-robin counter
pub fn lb_advance(lb: State) -> State {
    let current = int_from_float(bs_mag(state_get_layer(lb, 8)) * 4.0);
    let next = (current + 1) % 4;
    return state_set_layer(lb, 8, bs_from_mag_clamped(float_from_int(next) / 4.0));
}

// Select least loaded node
pub fn lb_least_loaded(lb: State) -> Int {
    let l0 = bs_mag(state_get_layer(lb, 4));
    let l1 = bs_mag(state_get_layer(lb, 5));
    let l2 = bs_mag(state_get_layer(lb, 6));
    let l3 = bs_mag(state_get_layer(lb, 7));

    let min_load = l0;
    let min_node = 0;

    if l1 < min_load {
        let min_load = l1;
        let min_node = 1;
    }
    if l2 < min_load {
        let min_load = l2;
        let min_node = 2;
    }
    if l3 < min_load {
        let min_node = 3;
    }

    return min_node;
}

// Route request using configured algorithm
pub fn lb_route(lb: State) -> Int {
    let algo = int_from_float(bs_mag(state_get_layer(lb, 9)) * 4.0);

    if algo == LB_ROUND_ROBIN() {
        return lb_next_round_robin(lb);
    }

    if algo == LB_LEAST_LOADED() {
        return lb_least_loaded(lb);
    }

    // Default to round-robin
    return lb_next_round_robin(lb);
}

