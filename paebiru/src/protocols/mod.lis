// Paebiru ML Library - Protocols Module
// Communication protocols for distributed inference

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Protocol Types
// =============================================================================

pub fn PROTO_GRPC() -> Int { return 0; }
pub fn PROTO_REST() -> Int { return 1; }
pub fn PROTO_MQTT() -> Int { return 2; }
pub fn PROTO_WEBSOCKET() -> Int { return 3; }
pub fn PROTO_NATS() -> Int { return 4; }
pub fn PROTO_KAFKA() -> Int { return 5; }

// =============================================================================
// Message Structure
// =============================================================================

// Message state layout:
// Layer 0: message type
// Layer 1: sequence number (normalized)
// Layer 2: priority
// Layer 3: timestamp (normalized)
// Layers 4-15: payload

// Create message
pub fn message_create(msg_type: Int, seq: Int, priority: Int, timestamp: Float) -> State {
    let msg = state_vacuum();

    let msg = state_set_layer(msg, 0, bs_from_mag_clamped(float_from_int(msg_type) / 16.0));
    let msg = state_set_layer(msg, 1, bs_from_mag_clamped(float_from_int(seq % 256) / 256.0));
    let msg = state_set_layer(msg, 2, bs_from_mag_clamped(float_from_int(priority) / 8.0));
    let msg = state_set_layer(msg, 3, bs_from_mag_clamped(timestamp / 1e9));

    return msg;
}

// Message types
pub fn MSG_REQUEST() -> Int { return 0; }
pub fn MSG_RESPONSE() -> Int { return 1; }
pub fn MSG_HEARTBEAT() -> Int { return 2; }
pub fn MSG_ERROR() -> Int { return 3; }
pub fn MSG_DATA() -> Int { return 4; }
pub fn MSG_ACK() -> Int { return 5; }

// Extract message fields
pub fn msg_type(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 0)) * 16.0);
}

pub fn msg_seq(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 1)) * 256.0);
}

pub fn msg_priority(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 2)) * 8.0);
}

pub fn msg_timestamp(msg: State) -> Float {
    return bs_mag(state_get_layer(msg, 3)) * 1e9;
}

// Set payload (layers 4-15)
pub fn msg_set_payload(msg: State, payload: State) -> State {
    let result = msg;

    let result = state_set_layer(result, 4, state_get_layer(payload, 0));
    let result = state_set_layer(result, 5, state_get_layer(payload, 1));
    let result = state_set_layer(result, 6, state_get_layer(payload, 2));
    let result = state_set_layer(result, 7, state_get_layer(payload, 3));
    let result = state_set_layer(result, 8, state_get_layer(payload, 4));
    let result = state_set_layer(result, 9, state_get_layer(payload, 5));
    let result = state_set_layer(result, 10, state_get_layer(payload, 6));
    let result = state_set_layer(result, 11, state_get_layer(payload, 7));
    let result = state_set_layer(result, 12, state_get_layer(payload, 8));
    let result = state_set_layer(result, 13, state_get_layer(payload, 9));
    let result = state_set_layer(result, 14, state_get_layer(payload, 10));
    let result = state_set_layer(result, 15, state_get_layer(payload, 11));

    return result;
}

// Get payload from message
pub fn msg_get_payload(msg: State) -> State {
    let payload = state_vacuum();

    let payload = state_set_layer(payload, 0, state_get_layer(msg, 4));
    let payload = state_set_layer(payload, 1, state_get_layer(msg, 5));
    let payload = state_set_layer(payload, 2, state_get_layer(msg, 6));
    let payload = state_set_layer(payload, 3, state_get_layer(msg, 7));
    let payload = state_set_layer(payload, 4, state_get_layer(msg, 8));
    let payload = state_set_layer(payload, 5, state_get_layer(msg, 9));
    let payload = state_set_layer(payload, 6, state_get_layer(msg, 10));
    let payload = state_set_layer(payload, 7, state_get_layer(msg, 11));
    let payload = state_set_layer(payload, 8, state_get_layer(msg, 12));
    let payload = state_set_layer(payload, 9, state_get_layer(msg, 13));
    let payload = state_set_layer(payload, 10, state_get_layer(msg, 14));
    let payload = state_set_layer(payload, 11, state_get_layer(msg, 15));

    return payload;
}

// =============================================================================
// Message Queue
// =============================================================================

// Queue with 4 slots (represented as 4 States)
// Each slot has: valid flag in layer 0

// Check if queue slot is empty
pub fn queue_slot_empty(slot: State) -> Bool {
    return bs_mag(state_get_layer(slot, 0)) < 0.1;
}

// Mark slot as occupied
pub fn queue_slot_fill(msg: State) -> State {
    return state_set_layer(msg, 0, bs_from_mag_clamped(1.0));
}

// Mark slot as empty
pub fn queue_slot_clear(slot: State) -> State {
    return state_set_layer(slot, 0, bs_from_mag_clamped(0.0));
}

// =============================================================================
// Request/Response Pattern
// =============================================================================

// Create request message
pub fn request_create(seq: Int, payload: State) -> State {
    let msg = message_create(MSG_REQUEST(), seq, 1, 0.0);
    return msg_set_payload(msg, payload);
}

// Create response message
pub fn response_create(seq: Int, payload: State) -> State {
    let msg = message_create(MSG_RESPONSE(), seq, 1, 0.0);
    return msg_set_payload(msg, payload);
}

// Create error response
pub fn error_create(seq: Int, error_code: Int) -> State {
    let msg = message_create(MSG_ERROR(), seq, 2, 0.0);
    let payload = state_vacuum();
    let payload = state_set_layer(payload, 0, bs_from_mag_clamped(float_from_int(error_code) / 256.0));
    return msg_set_payload(msg, payload);
}

// Create acknowledgment
pub fn ack_create(seq: Int) -> State {
    return message_create(MSG_ACK(), seq, 0, 0.0);
}

// Create heartbeat
pub fn heartbeat_create(timestamp: Float) -> State {
    return message_create(MSG_HEARTBEAT(), 0, 0, timestamp);
}

// =============================================================================
// Connection State
// =============================================================================

// Connection state layout:
// Layer 0: connected flag
// Layer 1: protocol type
// Layer 2: last activity timestamp
// Layer 3: retry count

// Create connection state
pub fn connection_create(protocol: Int) -> State {
    let conn = state_vacuum();
    let conn = state_set_layer(conn, 0, bs_from_mag_clamped(0.0));  // Not connected
    let conn = state_set_layer(conn, 1, bs_from_mag_clamped(float_from_int(protocol) / 8.0));
    return conn;
}

// Mark connected
pub fn connection_connect(conn: State, timestamp: Float) -> State {
    let conn = state_set_layer(conn, 0, bs_from_mag_clamped(1.0));
    let conn = state_set_layer(conn, 2, bs_from_mag_clamped(timestamp / 1e9));
    let conn = state_set_layer(conn, 3, bs_from_mag_clamped(0.0));  // Reset retries
    return conn;
}

// Mark disconnected
pub fn connection_disconnect(conn: State) -> State {
    return state_set_layer(conn, 0, bs_from_mag_clamped(0.0));
}

// Check if connected
pub fn connection_is_connected(conn: State) -> Bool {
    return bs_mag(state_get_layer(conn, 0)) > 0.5;
}

// Increment retry count
pub fn connection_retry(conn: State) -> State {
    let retries = bs_mag(state_get_layer(conn, 3));
    return state_set_layer(conn, 3, bs_from_mag_clamped(retries + 1.0));
}

// Get retry count
pub fn connection_retry_count(conn: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(conn, 3)));
}

