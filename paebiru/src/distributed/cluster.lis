// Paebiru ML Library - Cluster Module
// Cluster-based distributed inference

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Partition Strategies
// =============================================================================

// How to partition work across cluster nodes
pub fn PARTITION_LAYER() -> Int { return 0; }      // Each node processes different layers
pub fn PARTITION_DATA() -> Int { return 1; }       // Each node processes different batches
pub fn PARTITION_PIPELINE() -> Int { return 2; }   // Pipeline stages across nodes
pub fn PARTITION_HYBRID() -> Int { return 3; }     // Adaptive combination

// =============================================================================
// Cluster Node
// =============================================================================

// Node state layout:
// Layer 0: node ID (normalized)
// Layer 1: capacity (0-1)
// Layer 2: current load (0-1)
// Layer 3: availability (1.0 = available)
// Layer 4: latency score (lower = better)
// Layers 5-15: reserved

// Create cluster node
pub fn cluster_node_create(node_id: Int, capacity: Float) -> State {
    let node = state_vacuum();

    let node = state_set_layer(node, 0, bs_from_mag_clamped(float_from_int(node_id % 256) / 256.0));
    let node = state_set_layer(node, 1, bs_from_mag_clamped(clamp_float(capacity, 0.0, 1.0)));
    let node = state_set_layer(node, 2, bs_from_mag_clamped(0.0));  // No load initially
    let node = state_set_layer(node, 3, bs_from_mag_clamped(1.0));  // Available
    let node = state_set_layer(node, 4, bs_from_mag_clamped(0.5));  // Default latency

    return node;
}

// Get node ID
pub fn node_id(node: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(node, 0)) * 256.0);
}

// Get node capacity
pub fn node_capacity(node: State) -> Float {
    return bs_mag(state_get_layer(node, 1));
}

// Get node current load
pub fn node_load(node: State) -> Float {
    return bs_mag(state_get_layer(node, 2));
}

// Set node load
pub fn node_set_load(node: State, load: Float) -> State {
    return state_set_layer(node, 2, bs_from_mag_clamped(clamp_float(load, 0.0, 1.0)));
}

// Check if node is available
pub fn node_available(node: State) -> Bool {
    return bs_mag(state_get_layer(node, 3)) > 0.5;
}

// Set node availability
pub fn node_set_available(node: State, available: Bool) -> State {
    if available {
        return state_set_layer(node, 3, bs_from_mag_clamped(1.0));
    }
    return state_set_layer(node, 3, bs_from_mag_clamped(0.0));
}

// Get node latency score
pub fn node_latency(node: State) -> Float {
    return bs_mag(state_get_layer(node, 4));
}

// Set node latency score
pub fn node_set_latency(node: State, latency: Float) -> State {
    return state_set_layer(node, 4, bs_from_mag_clamped(clamp_float(latency, 0.0, 1.0)));
}

// =============================================================================
// Cluster State
// =============================================================================

// Cluster state tracks up to 16 nodes (one per layer)
// Each layer stores node availability/health

// Initialize cluster state
pub fn cluster_init() -> State {
    return state_vacuum();
}

// Register node in cluster (mark layer as active)
pub fn cluster_register_node(cluster: State, node_idx: Int) -> State {
    if node_idx < 0 { return cluster; }
    if node_idx > 15 { return cluster; }

    return state_set_layer(cluster, node_idx, bs_from_mag_clamped(1.0));
}

// Unregister node from cluster
pub fn cluster_unregister_node(cluster: State, node_idx: Int) -> State {
    if node_idx < 0 { return cluster; }
    if node_idx > 15 { return cluster; }

    return state_set_layer(cluster, node_idx, bs_from_mag_clamped(0.0));
}

// Check if node is registered
pub fn cluster_node_active(cluster: State, node_idx: Int) -> Bool {
    if node_idx < 0 { return false; }
    if node_idx > 15 { return false; }

    return bs_mag(state_get_layer(cluster, node_idx)) > 0.5;
}

// Count active nodes in cluster
pub fn cluster_active_count(cluster: State) -> Int {
    let count = 0;

    let a0 = bs_mag(state_get_layer(cluster, 0));
    if a0 > 0.5 { let count = count + 1; }

    let a1 = bs_mag(state_get_layer(cluster, 1));
    if a1 > 0.5 { let count = count + 1; }

    let a2 = bs_mag(state_get_layer(cluster, 2));
    if a2 > 0.5 { let count = count + 1; }

    let a3 = bs_mag(state_get_layer(cluster, 3));
    if a3 > 0.5 { let count = count + 1; }

    let a4 = bs_mag(state_get_layer(cluster, 4));
    if a4 > 0.5 { let count = count + 1; }

    let a5 = bs_mag(state_get_layer(cluster, 5));
    if a5 > 0.5 { let count = count + 1; }

    let a6 = bs_mag(state_get_layer(cluster, 6));
    if a6 > 0.5 { let count = count + 1; }

    let a7 = bs_mag(state_get_layer(cluster, 7));
    if a7 > 0.5 { let count = count + 1; }

    let a8 = bs_mag(state_get_layer(cluster, 8));
    if a8 > 0.5 { let count = count + 1; }

    let a9 = bs_mag(state_get_layer(cluster, 9));
    if a9 > 0.5 { let count = count + 1; }

    let a10 = bs_mag(state_get_layer(cluster, 10));
    if a10 > 0.5 { let count = count + 1; }

    let a11 = bs_mag(state_get_layer(cluster, 11));
    if a11 > 0.5 { let count = count + 1; }

    let a12 = bs_mag(state_get_layer(cluster, 12));
    if a12 > 0.5 { let count = count + 1; }

    let a13 = bs_mag(state_get_layer(cluster, 13));
    if a13 > 0.5 { let count = count + 1; }

    let a14 = bs_mag(state_get_layer(cluster, 14));
    if a14 > 0.5 { let count = count + 1; }

    let a15 = bs_mag(state_get_layer(cluster, 15));
    if a15 > 0.5 { let count = count + 1; }

    return count;
}

// =============================================================================
// Work Distribution
// =============================================================================

// Compute which node should handle a given layer (layer parallel)
pub fn assign_layer_to_node(layer_idx: Int, num_nodes: Int) -> Int {
    if num_nodes <= 0 { return 0; }
    return layer_idx % num_nodes;
}

// Compute which node should handle a given batch item (data parallel)
pub fn assign_batch_to_node(batch_idx: Int, num_nodes: Int) -> Int {
    if num_nodes <= 0 { return 0; }
    return batch_idx % num_nodes;
}

// Compute pipeline stage for a layer
pub fn pipeline_stage(layer_idx: Int, num_stages: Int) -> Int {
    if num_stages <= 0 { return 0; }
    // 16 layers distributed across num_stages
    let layers_per_stage = 16 / num_stages;
    if layers_per_stage < 1 { let layers_per_stage = 1; }
    return layer_idx / layers_per_stage;
}

// =============================================================================
// Load Balancing
// =============================================================================

// Find least loaded node among first n nodes
pub fn find_least_loaded_4(n0: State, n1: State, n2: State, n3: State) -> Int {
    let l0 = node_load(n0);
    let l1 = node_load(n1);
    let l2 = node_load(n2);
    let l3 = node_load(n3);

    let a0 = node_available(n0);
    let a1 = node_available(n1);
    let a2 = node_available(n2);
    let a3 = node_available(n3);

    // Set unavailable nodes to load 2.0 (beyond max)
    if !a0 { let l0 = 2.0; }
    if !a1 { let l1 = 2.0; }
    if !a2 { let l2 = 2.0; }
    if !a3 { let l3 = 2.0; }

    let min_load = l0;
    let min_idx = 0;

    if l1 < min_load {
        let min_load = l1;
        let min_idx = 1;
    }
    if l2 < min_load {
        let min_load = l2;
        let min_idx = 2;
    }
    if l3 < min_load {
        let min_idx = 3;
    }

    return min_idx;
}

// Weighted capacity selection (higher capacity = more work)
pub fn capacity_weighted_assignment(capacity: Float, total_capacity: Float, total_work: Int) -> Int {
    if total_capacity < 0.001 { return 0; }
    let ratio = capacity / total_capacity;
    return int_from_float(float_from_int(total_work) * ratio);
}

// =============================================================================
// Synchronization Barriers
// =============================================================================

// Barrier state: tracks how many nodes have reached barrier
// Layer 0: barrier ID
// Layer 1: expected count
// Layer 2: current count

pub fn barrier_create(barrier_id: Int, expected_count: Int) -> State {
    let barrier = state_vacuum();

    let barrier = state_set_layer(barrier, 0, bs_from_mag_clamped(float_from_int(barrier_id % 256) / 256.0));
    let barrier = state_set_layer(barrier, 1, bs_from_mag_clamped(float_from_int(expected_count) / 16.0));
    let barrier = state_set_layer(barrier, 2, bs_from_mag_clamped(0.0));

    return barrier;
}

pub fn barrier_arrive(barrier: State) -> State {
    let current = bs_mag(state_get_layer(barrier, 2)) * 16.0;
    let new_count = current + 1.0;
    return state_set_layer(barrier, 2, bs_from_mag_clamped(new_count / 16.0));
}

pub fn barrier_complete(barrier: State) -> Bool {
    let expected = bs_mag(state_get_layer(barrier, 1)) * 16.0;
    let current = bs_mag(state_get_layer(barrier, 2)) * 16.0;
    return current >= expected;
}

pub fn barrier_reset(barrier: State) -> State {
    return state_set_layer(barrier, 2, bs_from_mag_clamped(0.0));
}

