// Paebiru ML Library - Mesh Module
// Peer-to-peer mesh networking for distributed inference

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Mesh Network Types
// =============================================================================

// Network topology types
pub fn TOPOLOGY_FULL() -> Int { return 0; }      // Fully connected
pub fn TOPOLOGY_RING() -> Int { return 1; }      // Ring topology
pub fn TOPOLOGY_STAR() -> Int { return 2; }      // Star topology
pub fn TOPOLOGY_TREE() -> Int { return 3; }      // Tree topology
pub fn TOPOLOGY_RANDOM() -> Int { return 4; }    // Random connections

// =============================================================================
// Mesh Node
// =============================================================================

// Mesh node state layout:
// Layer 0: node ID (normalized)
// Layer 1: peer count
// Layer 2: message queue length
// Layer 3: online status
// Layer 4: reputation score
// Layers 5-15: peer connection flags

// Create mesh node
pub fn mesh_node_create(node_id: Int) -> State {
    let node = state_vacuum();

    let node = state_set_layer(node, 0, bs_from_mag_clamped(float_from_int(node_id % 256) / 256.0));
    let node = state_set_layer(node, 1, bs_from_mag_clamped(0.0));  // No peers
    let node = state_set_layer(node, 2, bs_from_mag_clamped(0.0));  // Empty queue
    let node = state_set_layer(node, 3, bs_from_mag_clamped(1.0));  // Online
    let node = state_set_layer(node, 4, bs_from_mag_clamped(0.5));  // Neutral reputation

    return node;
}

// Get mesh node ID
pub fn mesh_node_id(node: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(node, 0)) * 256.0);
}

// Get peer count
pub fn mesh_peer_count(node: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(node, 1)) * 16.0);
}

// Check if node is online
pub fn mesh_node_online(node: State) -> Bool {
    return bs_mag(state_get_layer(node, 3)) > 0.5;
}

// Set node online/offline
pub fn mesh_set_online(node: State, online: Bool) -> State {
    if online {
        return state_set_layer(node, 3, bs_from_mag_clamped(1.0));
    }
    return state_set_layer(node, 3, bs_from_mag_clamped(0.0));
}

// Get reputation score
pub fn mesh_reputation(node: State) -> Float {
    return bs_mag(state_get_layer(node, 4));
}

// Update reputation (clamps to 0-1)
pub fn mesh_update_reputation(node: State, delta: Float) -> State {
    let current = bs_mag(state_get_layer(node, 4));
    let new_rep = clamp_float(current + delta, 0.0, 1.0);
    return state_set_layer(node, 4, bs_from_mag_clamped(new_rep));
}

// =============================================================================
// Peer Connections
// =============================================================================

// Add peer connection (stores in layers 5-15)
pub fn mesh_add_peer(node: State, peer_slot: Int) -> State {
    if peer_slot < 0 { return node; }
    if peer_slot > 10 { return node; }  // Slots 0-10 = layers 5-15

    let layer = peer_slot + 5;
    let count = mesh_peer_count(node);

    let node = state_set_layer(node, layer, bs_from_mag_clamped(1.0));
    let node = state_set_layer(node, 1, bs_from_mag_clamped(float_from_int(count + 1) / 16.0));

    return node;
}

// Remove peer connection
pub fn mesh_remove_peer(node: State, peer_slot: Int) -> State {
    if peer_slot < 0 { return node; }
    if peer_slot > 10 { return node; }

    let layer = peer_slot + 5;
    let was_connected = bs_mag(state_get_layer(node, layer)) > 0.5;

    let node = state_set_layer(node, layer, bs_from_mag_clamped(0.0));

    if was_connected {
        let count = mesh_peer_count(node);
        if count > 0 {
            let node = state_set_layer(node, 1, bs_from_mag_clamped(float_from_int(count - 1) / 16.0));
        }
    }

    return node;
}

// Check if peer is connected
pub fn mesh_peer_connected(node: State, peer_slot: Int) -> Bool {
    if peer_slot < 0 { return false; }
    if peer_slot > 10 { return false; }

    let layer = peer_slot + 5;
    return bs_mag(state_get_layer(node, layer)) > 0.5;
}

// =============================================================================
// Gossip Protocol
// =============================================================================

// Gossip message state layout:
// Layer 0: message type
// Layer 1: TTL (time to live)
// Layer 2: source node (normalized)
// Layer 3: timestamp (normalized)
// Layers 4-15: payload

pub fn GOSSIP_DATA() -> Int { return 0; }       // Data propagation
pub fn GOSSIP_QUERY() -> Int { return 1; }      // Query/request
pub fn GOSSIP_HEARTBEAT() -> Int { return 2; }  // Keep-alive
pub fn GOSSIP_ANNOUNCE() -> Int { return 3; }   // New node announcement

// Create gossip message
pub fn gossip_create(msg_type: Int, source_node: Int, ttl: Int) -> State {
    let msg = state_vacuum();

    let msg = state_set_layer(msg, 0, bs_from_mag_clamped(float_from_int(msg_type) / 8.0));
    let msg = state_set_layer(msg, 1, bs_from_mag_clamped(float_from_int(ttl) / 16.0));
    let msg = state_set_layer(msg, 2, bs_from_mag_clamped(float_from_int(source_node % 256) / 256.0));

    return msg;
}

// Get gossip message type
pub fn gossip_type(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 0)) * 8.0);
}

// Get gossip TTL
pub fn gossip_ttl(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 1)) * 16.0);
}

// Decrement TTL (for forwarding)
pub fn gossip_decrement_ttl(msg: State) -> State {
    let current_ttl = gossip_ttl(msg);
    if current_ttl > 0 {
        return state_set_layer(msg, 1, bs_from_mag_clamped(float_from_int(current_ttl - 1) / 16.0));
    }
    return msg;
}

// Check if message should be forwarded
pub fn gossip_should_forward(msg: State) -> Bool {
    return gossip_ttl(msg) > 0;
}

// Get source node
pub fn gossip_source(msg: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(msg, 2)) * 256.0);
}

// Set payload data (uses layers 4-15)
pub fn gossip_set_payload(msg: State, payload: State) -> State {
    let result = msg;

    let result = state_set_layer(result, 4, state_get_layer(payload, 0));
    let result = state_set_layer(result, 5, state_get_layer(payload, 1));
    let result = state_set_layer(result, 6, state_get_layer(payload, 2));
    let result = state_set_layer(result, 7, state_get_layer(payload, 3));
    let result = state_set_layer(result, 8, state_get_layer(payload, 4));
    let result = state_set_layer(result, 9, state_get_layer(payload, 5));
    let result = state_set_layer(result, 10, state_get_layer(payload, 6));
    let result = state_set_layer(result, 11, state_get_layer(payload, 7));
    let result = state_set_layer(result, 12, state_get_layer(payload, 8));
    let result = state_set_layer(result, 13, state_get_layer(payload, 9));
    let result = state_set_layer(result, 14, state_get_layer(payload, 10));
    let result = state_set_layer(result, 15, state_get_layer(payload, 11));

    return result;
}

// Get payload data
pub fn gossip_get_payload(msg: State) -> State {
    let payload = state_vacuum();

    let payload = state_set_layer(payload, 0, state_get_layer(msg, 4));
    let payload = state_set_layer(payload, 1, state_get_layer(msg, 5));
    let payload = state_set_layer(payload, 2, state_get_layer(msg, 6));
    let payload = state_set_layer(payload, 3, state_get_layer(msg, 7));
    let payload = state_set_layer(payload, 4, state_get_layer(msg, 8));
    let payload = state_set_layer(payload, 5, state_get_layer(msg, 9));
    let payload = state_set_layer(payload, 6, state_get_layer(msg, 10));
    let payload = state_set_layer(payload, 7, state_get_layer(msg, 11));
    let payload = state_set_layer(payload, 8, state_get_layer(msg, 12));
    let payload = state_set_layer(payload, 9, state_get_layer(msg, 13));
    let payload = state_set_layer(payload, 10, state_get_layer(msg, 14));
    let payload = state_set_layer(payload, 11, state_get_layer(msg, 15));

    return payload;
}

// =============================================================================
// Broadcast Strategies
// =============================================================================

// Select peers for broadcast (epidemic style)
// Returns number of peers to forward to based on fanout
pub fn broadcast_fanout(peer_count: Int, fanout_ratio: Float) -> Int {
    let target = float_from_int(peer_count) * fanout_ratio;
    let result = int_from_float(target);
    if result < 1 { return 1; }
    if result > peer_count { return peer_count; }
    return result;
}

// Compute message hash for deduplication
pub fn message_hash(msg: State) -> Int {
    return state_hash(msg) % 65536;
}

// =============================================================================
// Membership Management
// =============================================================================

// Membership list state: each layer represents a known node (0/1)
pub fn membership_init() -> State {
    return state_vacuum();
}

pub fn membership_add(members: State, node_idx: Int) -> State {
    if node_idx < 0 { return members; }
    if node_idx > 15 { return members; }
    return state_set_layer(members, node_idx, bs_from_mag_clamped(1.0));
}

pub fn membership_remove(members: State, node_idx: Int) -> State {
    if node_idx < 0 { return members; }
    if node_idx > 15 { return members; }
    return state_set_layer(members, node_idx, bs_from_mag_clamped(0.0));
}

pub fn membership_contains(members: State, node_idx: Int) -> Bool {
    if node_idx < 0 { return false; }
    if node_idx > 15 { return false; }
    return bs_mag(state_get_layer(members, node_idx)) > 0.5;
}

// Count members
pub fn membership_count(members: State) -> Int {
    let count = 0;

    if bs_mag(state_get_layer(members, 0)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 1)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 2)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 3)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 4)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 5)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 6)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 7)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 8)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 9)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 10)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 11)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 12)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 13)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 14)) > 0.5 { let count = count + 1; }
    if bs_mag(state_get_layer(members, 15)) > 0.5 { let count = count + 1; }

    return count;
}

