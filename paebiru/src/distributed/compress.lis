// Paebiru Distributed ML - Gradient Compression
// Tecnicas para reduzir bandwidth em treinamento distribuido
//
// Metodos incluem:
// - Top-K sparsification
// - Random sparsification
// - Quantization
// - Error feedback

use core::bytesil::{bs_mag, bs_from_mag_clamped};
use core::state::{st_add, st_sub, st_scale, st_max_mag};

// =============================================================================
// Top-K Sparsification
// =============================================================================

// Find k-th largest magnitude threshold
fn find_topk_threshold(s: State, k: Int) -> Float {
    let max_val = st_max_mag(s);
    let ratio = 1.0 - (k * 1.0 / 16.0);
    return max_val * ratio;
}

// Top-K sparsification: keep only k largest magnitude elements
pub fn topk_sparsify(gradients: State, k: Int) -> State {
    let threshold = find_topk_threshold(gradients, k);
    let r = state_vacuum();

    let m0 = bs_mag(state_get_layer(gradients, 0));
    if m0 >= threshold {
        let r = state_set_layer(r, 0, state_get_layer(gradients, 0));
    }

    let m1 = bs_mag(state_get_layer(gradients, 1));
    if m1 >= threshold {
        let r = state_set_layer(r, 1, state_get_layer(gradients, 1));
    }

    let m2 = bs_mag(state_get_layer(gradients, 2));
    if m2 >= threshold {
        let r = state_set_layer(r, 2, state_get_layer(gradients, 2));
    }

    let m3 = bs_mag(state_get_layer(gradients, 3));
    if m3 >= threshold {
        let r = state_set_layer(r, 3, state_get_layer(gradients, 3));
    }

    let m4 = bs_mag(state_get_layer(gradients, 4));
    if m4 >= threshold {
        let r = state_set_layer(r, 4, state_get_layer(gradients, 4));
    }

    let m5 = bs_mag(state_get_layer(gradients, 5));
    if m5 >= threshold {
        let r = state_set_layer(r, 5, state_get_layer(gradients, 5));
    }

    let m6 = bs_mag(state_get_layer(gradients, 6));
    if m6 >= threshold {
        let r = state_set_layer(r, 6, state_get_layer(gradients, 6));
    }

    let m7 = bs_mag(state_get_layer(gradients, 7));
    if m7 >= threshold {
        let r = state_set_layer(r, 7, state_get_layer(gradients, 7));
    }

    let m8 = bs_mag(state_get_layer(gradients, 8));
    if m8 >= threshold {
        let r = state_set_layer(r, 8, state_get_layer(gradients, 8));
    }

    let m9 = bs_mag(state_get_layer(gradients, 9));
    if m9 >= threshold {
        let r = state_set_layer(r, 9, state_get_layer(gradients, 9));
    }

    let m10 = bs_mag(state_get_layer(gradients, 10));
    if m10 >= threshold {
        let r = state_set_layer(r, 10, state_get_layer(gradients, 10));
    }

    let m11 = bs_mag(state_get_layer(gradients, 11));
    if m11 >= threshold {
        let r = state_set_layer(r, 11, state_get_layer(gradients, 11));
    }

    let m12 = bs_mag(state_get_layer(gradients, 12));
    if m12 >= threshold {
        let r = state_set_layer(r, 12, state_get_layer(gradients, 12));
    }

    let m13 = bs_mag(state_get_layer(gradients, 13));
    if m13 >= threshold {
        let r = state_set_layer(r, 13, state_get_layer(gradients, 13));
    }

    let m14 = bs_mag(state_get_layer(gradients, 14));
    if m14 >= threshold {
        let r = state_set_layer(r, 14, state_get_layer(gradients, 14));
    }

    let m15 = bs_mag(state_get_layer(gradients, 15));
    if m15 >= threshold {
        let r = state_set_layer(r, 15, state_get_layer(gradients, 15));
    }

    return r;
}

// =============================================================================
// Random Sparsification
// =============================================================================

// Simple hash for pseudo-random selection
fn hash_select(seed: Float, idx: Float) -> Float {
    let x = (seed + idx) * 0.6180339887;
    return x - floor(x);
}

// Random sparsification: keep elements with probability p
pub fn random_sparsify(gradients: State, p: Float, seed: Float) -> State {
    let scale = 1.0 / p;
    let r = state_vacuum();

    if hash_select(seed, 0.0) < p {
        let r = state_set_layer(r, 0, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 0)) * scale));
    }
    if hash_select(seed, 1.0) < p {
        let r = state_set_layer(r, 1, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 1)) * scale));
    }
    if hash_select(seed, 2.0) < p {
        let r = state_set_layer(r, 2, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 2)) * scale));
    }
    if hash_select(seed, 3.0) < p {
        let r = state_set_layer(r, 3, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 3)) * scale));
    }
    if hash_select(seed, 4.0) < p {
        let r = state_set_layer(r, 4, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 4)) * scale));
    }
    if hash_select(seed, 5.0) < p {
        let r = state_set_layer(r, 5, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 5)) * scale));
    }
    if hash_select(seed, 6.0) < p {
        let r = state_set_layer(r, 6, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 6)) * scale));
    }
    if hash_select(seed, 7.0) < p {
        let r = state_set_layer(r, 7, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 7)) * scale));
    }
    if hash_select(seed, 8.0) < p {
        let r = state_set_layer(r, 8, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 8)) * scale));
    }
    if hash_select(seed, 9.0) < p {
        let r = state_set_layer(r, 9, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 9)) * scale));
    }
    if hash_select(seed, 10.0) < p {
        let r = state_set_layer(r, 10, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 10)) * scale));
    }
    if hash_select(seed, 11.0) < p {
        let r = state_set_layer(r, 11, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 11)) * scale));
    }
    if hash_select(seed, 12.0) < p {
        let r = state_set_layer(r, 12, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 12)) * scale));
    }
    if hash_select(seed, 13.0) < p {
        let r = state_set_layer(r, 13, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 13)) * scale));
    }
    if hash_select(seed, 14.0) < p {
        let r = state_set_layer(r, 14, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 14)) * scale));
    }
    if hash_select(seed, 15.0) < p {
        let r = state_set_layer(r, 15, bs_from_mag_clamped(bs_mag(state_get_layer(gradients, 15)) * scale));
    }

    return r;
}

// =============================================================================
// Quantization
// =============================================================================

// Quantize to int8 equivalent
pub fn quantize_int8(gradients: State) -> State {
    let max_mag = st_max_mag(gradients) + 0.0001;
    let scale = max_mag / 127.0;
    let inv_scale = 1.0 / scale;

    let r = state_vacuum();

    let q0 = floor(bs_mag(state_get_layer(gradients, 0)) * inv_scale + 0.5);
    let r = state_set_layer(r, 0, bs_from_mag_clamped(clamp_float(q0, -128.0, 127.0)));

    let q1 = floor(bs_mag(state_get_layer(gradients, 1)) * inv_scale + 0.5);
    let r = state_set_layer(r, 1, bs_from_mag_clamped(clamp_float(q1, -128.0, 127.0)));

    let q2 = floor(bs_mag(state_get_layer(gradients, 2)) * inv_scale + 0.5);
    let r = state_set_layer(r, 2, bs_from_mag_clamped(clamp_float(q2, -128.0, 127.0)));

    let q3 = floor(bs_mag(state_get_layer(gradients, 3)) * inv_scale + 0.5);
    let r = state_set_layer(r, 3, bs_from_mag_clamped(clamp_float(q3, -128.0, 127.0)));

    let q4 = floor(bs_mag(state_get_layer(gradients, 4)) * inv_scale + 0.5);
    let r = state_set_layer(r, 4, bs_from_mag_clamped(clamp_float(q4, -128.0, 127.0)));

    let q5 = floor(bs_mag(state_get_layer(gradients, 5)) * inv_scale + 0.5);
    let r = state_set_layer(r, 5, bs_from_mag_clamped(clamp_float(q5, -128.0, 127.0)));

    let q6 = floor(bs_mag(state_get_layer(gradients, 6)) * inv_scale + 0.5);
    let r = state_set_layer(r, 6, bs_from_mag_clamped(clamp_float(q6, -128.0, 127.0)));

    let q7 = floor(bs_mag(state_get_layer(gradients, 7)) * inv_scale + 0.5);
    let r = state_set_layer(r, 7, bs_from_mag_clamped(clamp_float(q7, -128.0, 127.0)));

    let q8 = floor(bs_mag(state_get_layer(gradients, 8)) * inv_scale + 0.5);
    let r = state_set_layer(r, 8, bs_from_mag_clamped(clamp_float(q8, -128.0, 127.0)));

    let q9 = floor(bs_mag(state_get_layer(gradients, 9)) * inv_scale + 0.5);
    let r = state_set_layer(r, 9, bs_from_mag_clamped(clamp_float(q9, -128.0, 127.0)));

    let q10 = floor(bs_mag(state_get_layer(gradients, 10)) * inv_scale + 0.5);
    let r = state_set_layer(r, 10, bs_from_mag_clamped(clamp_float(q10, -128.0, 127.0)));

    let q11 = floor(bs_mag(state_get_layer(gradients, 11)) * inv_scale + 0.5);
    let r = state_set_layer(r, 11, bs_from_mag_clamped(clamp_float(q11, -128.0, 127.0)));

    let q12 = floor(bs_mag(state_get_layer(gradients, 12)) * inv_scale + 0.5);
    let r = state_set_layer(r, 12, bs_from_mag_clamped(clamp_float(q12, -128.0, 127.0)));

    let q13 = floor(bs_mag(state_get_layer(gradients, 13)) * inv_scale + 0.5);
    let r = state_set_layer(r, 13, bs_from_mag_clamped(clamp_float(q13, -128.0, 127.0)));

    let q14 = floor(bs_mag(state_get_layer(gradients, 14)) * inv_scale + 0.5);
    let r = state_set_layer(r, 14, bs_from_mag_clamped(clamp_float(q14, -128.0, 127.0)));

    let q15 = floor(bs_mag(state_get_layer(gradients, 15)) * inv_scale + 0.5);
    let r = state_set_layer(r, 15, bs_from_mag_clamped(clamp_float(q15, -128.0, 127.0)));

    return r;
}

// Get scale factor for int8 quantization
pub fn get_int8_scale(gradients: State) -> Float {
    let max_mag = st_max_mag(gradients) + 0.0001;
    return max_mag / 127.0;
}

// Dequantize from int8
pub fn dequantize_int8(quantized: State, scale: Float) -> State {
    return st_scale(quantized, scale);
}

// =============================================================================
// Error Feedback
// =============================================================================

// Compute compression error
pub fn compression_error(original: State, compressed: State) -> State {
    return st_sub(original, compressed);
}

// Apply error feedback
pub fn apply_error_feedback(gradient: State, accumulated_error: State) -> State {
    return st_add(gradient, accumulated_error);
}

// Update accumulated error
pub fn update_error(prev_error: State, new_error: State, decay: Float) -> State {
    let decayed = st_scale(prev_error, decay);
    return st_add(decayed, new_error);
}

// =============================================================================
// Compression Pipeline
// =============================================================================

// Full compression with error feedback
pub fn compress_with_feedback(gradient: State, accumulated_error: State, k: Int) -> State {
    let corrected = apply_error_feedback(gradient, accumulated_error);
    return topk_sparsify(corrected, k);
}

// Compute new accumulated error
pub fn compute_new_error(
    gradient: State,
    accumulated_error: State,
    compressed: State,
    decay: Float
) -> State {
    let corrected = apply_error_feedback(gradient, accumulated_error);
    let new_error = compression_error(corrected, compressed);
    return update_error(accumulated_error, new_error, decay);
}

// =============================================================================
// Compression Metrics
// =============================================================================

// Compute sparsity (fraction of zeros)
pub fn compute_sparsity(s: State) -> Float {
    let threshold = 0.0001;
    let zero_count = 0.0;

    if bs_mag(state_get_layer(s, 0)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 1)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 2)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 3)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 4)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 5)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 6)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 7)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 8)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 9)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 10)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 11)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 12)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 13)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 14)) < threshold { let zero_count = zero_count + 1.0; }
    if bs_mag(state_get_layer(s, 15)) < threshold { let zero_count = zero_count + 1.0; }

    return zero_count / 16.0;
}

// Estimated compression ratio
pub fn compression_ratio(sparsity: Float) -> Float {
    let non_zero_fraction = 1.0 - sparsity;
    return 1.0 / (non_zero_fraction * 1.5 + 0.1);
}

