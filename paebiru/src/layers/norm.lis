// Paebiru ML Library - Normalization Layers
// LayerNorm, RMSNorm e variantes

use core::bytesil::{bs_mag, bs_from_mag_clamped, bs_one};
use core::state::{st_mean, st_variance, st_sum_mag_sq};

// =============================================================================
// Layer Normalization
// =============================================================================

// Layer Normalization com parametros learnable
pub fn layer_norm(input: State, gamma: State, beta: State, eps: Float) -> State {
    let mean = st_mean(input);
    let variance = st_variance(input);
    let std = sqrt(variance + eps);

    let result = state_vacuum();

    let m0 = bs_mag(state_get_layer(input, 0));
    let g0 = bs_mag(state_get_layer(gamma, 0));
    let b0 = bs_mag(state_get_layer(beta, 0));
    let n0 = ((m0 - mean) / std) * g0 + b0;
    let result = state_set_layer(result, 0, bs_from_mag_clamped(n0));

    let m1 = bs_mag(state_get_layer(input, 1));
    let g1 = bs_mag(state_get_layer(gamma, 1));
    let b1 = bs_mag(state_get_layer(beta, 1));
    let n1 = ((m1 - mean) / std) * g1 + b1;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(n1));

    let m2 = bs_mag(state_get_layer(input, 2));
    let g2 = bs_mag(state_get_layer(gamma, 2));
    let b2 = bs_mag(state_get_layer(beta, 2));
    let n2 = ((m2 - mean) / std) * g2 + b2;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(n2));

    let m3 = bs_mag(state_get_layer(input, 3));
    let g3 = bs_mag(state_get_layer(gamma, 3));
    let b3 = bs_mag(state_get_layer(beta, 3));
    let n3 = ((m3 - mean) / std) * g3 + b3;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(n3));

    let m4 = bs_mag(state_get_layer(input, 4));
    let g4 = bs_mag(state_get_layer(gamma, 4));
    let b4 = bs_mag(state_get_layer(beta, 4));
    let n4 = ((m4 - mean) / std) * g4 + b4;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(n4));

    let m5 = bs_mag(state_get_layer(input, 5));
    let g5 = bs_mag(state_get_layer(gamma, 5));
    let b5 = bs_mag(state_get_layer(beta, 5));
    let n5 = ((m5 - mean) / std) * g5 + b5;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(n5));

    let m6 = bs_mag(state_get_layer(input, 6));
    let g6 = bs_mag(state_get_layer(gamma, 6));
    let b6 = bs_mag(state_get_layer(beta, 6));
    let n6 = ((m6 - mean) / std) * g6 + b6;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(n6));

    let m7 = bs_mag(state_get_layer(input, 7));
    let g7 = bs_mag(state_get_layer(gamma, 7));
    let b7 = bs_mag(state_get_layer(beta, 7));
    let n7 = ((m7 - mean) / std) * g7 + b7;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(n7));

    let m8 = bs_mag(state_get_layer(input, 8));
    let g8 = bs_mag(state_get_layer(gamma, 8));
    let b8 = bs_mag(state_get_layer(beta, 8));
    let n8 = ((m8 - mean) / std) * g8 + b8;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(n8));

    let m9 = bs_mag(state_get_layer(input, 9));
    let g9 = bs_mag(state_get_layer(gamma, 9));
    let b9 = bs_mag(state_get_layer(beta, 9));
    let n9 = ((m9 - mean) / std) * g9 + b9;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(n9));

    let m10 = bs_mag(state_get_layer(input, 10));
    let g10 = bs_mag(state_get_layer(gamma, 10));
    let b10 = bs_mag(state_get_layer(beta, 10));
    let n10 = ((m10 - mean) / std) * g10 + b10;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(n10));

    let m11 = bs_mag(state_get_layer(input, 11));
    let g11 = bs_mag(state_get_layer(gamma, 11));
    let b11 = bs_mag(state_get_layer(beta, 11));
    let n11 = ((m11 - mean) / std) * g11 + b11;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(n11));

    let m12 = bs_mag(state_get_layer(input, 12));
    let g12 = bs_mag(state_get_layer(gamma, 12));
    let b12 = bs_mag(state_get_layer(beta, 12));
    let n12 = ((m12 - mean) / std) * g12 + b12;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(n12));

    let m13 = bs_mag(state_get_layer(input, 13));
    let g13 = bs_mag(state_get_layer(gamma, 13));
    let b13 = bs_mag(state_get_layer(beta, 13));
    let n13 = ((m13 - mean) / std) * g13 + b13;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(n13));

    let m14 = bs_mag(state_get_layer(input, 14));
    let g14 = bs_mag(state_get_layer(gamma, 14));
    let b14 = bs_mag(state_get_layer(beta, 14));
    let n14 = ((m14 - mean) / std) * g14 + b14;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(n14));

    let m15 = bs_mag(state_get_layer(input, 15));
    let g15 = bs_mag(state_get_layer(gamma, 15));
    let b15 = bs_mag(state_get_layer(beta, 15));
    let n15 = ((m15 - mean) / std) * g15 + b15;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(n15));

    return result;
}

// =============================================================================
// RMS Normalization
// =============================================================================

// RMS Normalization (usado em LLaMA, etc.)
pub fn rms_norm(input: State, gamma: State, eps: Float) -> State {
    let sq_sum = st_sum_mag_sq(input);
    let rms = sqrt(sq_sum / 16.0 + eps);

    let result = state_vacuum();

    let m0 = bs_mag(state_get_layer(input, 0));
    let g0 = bs_mag(state_get_layer(gamma, 0));
    let n0 = (m0 / rms) * g0;
    let result = state_set_layer(result, 0, bs_from_mag_clamped(n0));

    let m1 = bs_mag(state_get_layer(input, 1));
    let g1 = bs_mag(state_get_layer(gamma, 1));
    let n1 = (m1 / rms) * g1;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(n1));

    let m2 = bs_mag(state_get_layer(input, 2));
    let g2 = bs_mag(state_get_layer(gamma, 2));
    let n2 = (m2 / rms) * g2;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(n2));

    let m3 = bs_mag(state_get_layer(input, 3));
    let g3 = bs_mag(state_get_layer(gamma, 3));
    let n3 = (m3 / rms) * g3;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(n3));

    let m4 = bs_mag(state_get_layer(input, 4));
    let g4 = bs_mag(state_get_layer(gamma, 4));
    let n4 = (m4 / rms) * g4;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(n4));

    let m5 = bs_mag(state_get_layer(input, 5));
    let g5 = bs_mag(state_get_layer(gamma, 5));
    let n5 = (m5 / rms) * g5;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(n5));

    let m6 = bs_mag(state_get_layer(input, 6));
    let g6 = bs_mag(state_get_layer(gamma, 6));
    let n6 = (m6 / rms) * g6;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(n6));

    let m7 = bs_mag(state_get_layer(input, 7));
    let g7 = bs_mag(state_get_layer(gamma, 7));
    let n7 = (m7 / rms) * g7;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(n7));

    let m8 = bs_mag(state_get_layer(input, 8));
    let g8 = bs_mag(state_get_layer(gamma, 8));
    let n8 = (m8 / rms) * g8;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(n8));

    let m9 = bs_mag(state_get_layer(input, 9));
    let g9 = bs_mag(state_get_layer(gamma, 9));
    let n9 = (m9 / rms) * g9;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(n9));

    let m10 = bs_mag(state_get_layer(input, 10));
    let g10 = bs_mag(state_get_layer(gamma, 10));
    let n10 = (m10 / rms) * g10;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(n10));

    let m11 = bs_mag(state_get_layer(input, 11));
    let g11 = bs_mag(state_get_layer(gamma, 11));
    let n11 = (m11 / rms) * g11;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(n11));

    let m12 = bs_mag(state_get_layer(input, 12));
    let g12 = bs_mag(state_get_layer(gamma, 12));
    let n12 = (m12 / rms) * g12;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(n12));

    let m13 = bs_mag(state_get_layer(input, 13));
    let g13 = bs_mag(state_get_layer(gamma, 13));
    let n13 = (m13 / rms) * g13;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(n13));

    let m14 = bs_mag(state_get_layer(input, 14));
    let g14 = bs_mag(state_get_layer(gamma, 14));
    let n14 = (m14 / rms) * g14;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(n14));

    let m15 = bs_mag(state_get_layer(input, 15));
    let g15 = bs_mag(state_get_layer(gamma, 15));
    let n15 = (m15 / rms) * g15;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(n15));

    return result;
}

// =============================================================================
// Simplified Normalization
// =============================================================================

// LayerNorm sem parametros learnable
pub fn layer_norm_simple(input: State, eps: Float) -> State {
    let mean = st_mean(input);
    let variance = st_variance(input);
    let std = sqrt(variance + eps);

    let result = state_vacuum();

    let m0 = bs_mag(state_get_layer(input, 0));
    let n0 = (m0 - mean) / std;
    let result = state_set_layer(result, 0, bs_from_mag_clamped(abs_float(n0)));

    let m1 = bs_mag(state_get_layer(input, 1));
    let n1 = (m1 - mean) / std;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(abs_float(n1)));

    let m2 = bs_mag(state_get_layer(input, 2));
    let n2 = (m2 - mean) / std;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(abs_float(n2)));

    let m3 = bs_mag(state_get_layer(input, 3));
    let n3 = (m3 - mean) / std;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(abs_float(n3)));

    let m4 = bs_mag(state_get_layer(input, 4));
    let n4 = (m4 - mean) / std;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(abs_float(n4)));

    let m5 = bs_mag(state_get_layer(input, 5));
    let n5 = (m5 - mean) / std;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(abs_float(n5)));

    let m6 = bs_mag(state_get_layer(input, 6));
    let n6 = (m6 - mean) / std;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(abs_float(n6)));

    let m7 = bs_mag(state_get_layer(input, 7));
    let n7 = (m7 - mean) / std;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(abs_float(n7)));

    let m8 = bs_mag(state_get_layer(input, 8));
    let n8 = (m8 - mean) / std;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(abs_float(n8)));

    let m9 = bs_mag(state_get_layer(input, 9));
    let n9 = (m9 - mean) / std;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(abs_float(n9)));

    let m10 = bs_mag(state_get_layer(input, 10));
    let n10 = (m10 - mean) / std;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(abs_float(n10)));

    let m11 = bs_mag(state_get_layer(input, 11));
    let n11 = (m11 - mean) / std;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(abs_float(n11)));

    let m12 = bs_mag(state_get_layer(input, 12));
    let n12 = (m12 - mean) / std;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(abs_float(n12)));

    let m13 = bs_mag(state_get_layer(input, 13));
    let n13 = (m13 - mean) / std;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(abs_float(n13)));

    let m14 = bs_mag(state_get_layer(input, 14));
    let n14 = (m14 - mean) / std;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(abs_float(n14)));

    let m15 = bs_mag(state_get_layer(input, 15));
    let n15 = (m15 - mean) / std;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(abs_float(n15)));

    return result;
}

// =============================================================================
// Initialization Helpers
// =============================================================================

// Inicializa gamma com uns (para RMS norm ou LayerNorm)
pub fn init_gamma_ones() -> State {
    let result = state_vacuum();
    let one = bs_one();

    let result = state_set_layer(result, 0, one);
    let result = state_set_layer(result, 1, one);
    let result = state_set_layer(result, 2, one);
    let result = state_set_layer(result, 3, one);
    let result = state_set_layer(result, 4, one);
    let result = state_set_layer(result, 5, one);
    let result = state_set_layer(result, 6, one);
    let result = state_set_layer(result, 7, one);
    let result = state_set_layer(result, 8, one);
    let result = state_set_layer(result, 9, one);
    let result = state_set_layer(result, 10, one);
    let result = state_set_layer(result, 11, one);
    let result = state_set_layer(result, 12, one);
    let result = state_set_layer(result, 13, one);
    let result = state_set_layer(result, 14, one);
    let result = state_set_layer(result, 15, one);

    return result;
}

// Inicializa beta com zeros (para LayerNorm)
pub fn init_beta_zeros() -> State {
    return state_vacuum();
}

// =============================================================================
// Batch Normalization
// =============================================================================

// Batch normalization (per-sample)
// Em SIL, operamos sobre um unico State por vez
// running_mean e running_var seriam mantidos externamente
pub fn batch_norm(input: State, gamma: State, beta: State, eps: Float) -> State {
    // Para um unico sample, batch_norm eh equivalente a layer_norm
    return layer_norm(input, gamma, beta, eps);
}

// Batch normalization sem parametros learnable
pub fn batch_norm_simple(input: State, eps: Float) -> State {
    return layer_norm_simple(input, eps);
}

// Batch normalization com estatisticas pre-computadas
// Usado durante inferencia com running_mean/running_var
pub fn batch_norm_inference(input: State, running_mean: Float, running_var: Float,
                            gamma: State, beta: State, eps: Float) -> State {
    let std = sqrt(running_var + eps);
    let result = state_vacuum();

    let m0 = bs_mag(state_get_layer(input, 0));
    let g0 = bs_mag(state_get_layer(gamma, 0));
    let b0 = bs_mag(state_get_layer(beta, 0));
    let n0 = ((m0 - running_mean) / std) * g0 + b0;
    let result = state_set_layer(result, 0, bs_from_mag_clamped(n0));

    let m1 = bs_mag(state_get_layer(input, 1));
    let g1 = bs_mag(state_get_layer(gamma, 1));
    let b1 = bs_mag(state_get_layer(beta, 1));
    let n1 = ((m1 - running_mean) / std) * g1 + b1;
    let result = state_set_layer(result, 1, bs_from_mag_clamped(n1));

    let m2 = bs_mag(state_get_layer(input, 2));
    let g2 = bs_mag(state_get_layer(gamma, 2));
    let b2 = bs_mag(state_get_layer(beta, 2));
    let n2 = ((m2 - running_mean) / std) * g2 + b2;
    let result = state_set_layer(result, 2, bs_from_mag_clamped(n2));

    let m3 = bs_mag(state_get_layer(input, 3));
    let g3 = bs_mag(state_get_layer(gamma, 3));
    let b3 = bs_mag(state_get_layer(beta, 3));
    let n3 = ((m3 - running_mean) / std) * g3 + b3;
    let result = state_set_layer(result, 3, bs_from_mag_clamped(n3));

    let m4 = bs_mag(state_get_layer(input, 4));
    let g4 = bs_mag(state_get_layer(gamma, 4));
    let b4 = bs_mag(state_get_layer(beta, 4));
    let n4 = ((m4 - running_mean) / std) * g4 + b4;
    let result = state_set_layer(result, 4, bs_from_mag_clamped(n4));

    let m5 = bs_mag(state_get_layer(input, 5));
    let g5 = bs_mag(state_get_layer(gamma, 5));
    let b5 = bs_mag(state_get_layer(beta, 5));
    let n5 = ((m5 - running_mean) / std) * g5 + b5;
    let result = state_set_layer(result, 5, bs_from_mag_clamped(n5));

    let m6 = bs_mag(state_get_layer(input, 6));
    let g6 = bs_mag(state_get_layer(gamma, 6));
    let b6 = bs_mag(state_get_layer(beta, 6));
    let n6 = ((m6 - running_mean) / std) * g6 + b6;
    let result = state_set_layer(result, 6, bs_from_mag_clamped(n6));

    let m7 = bs_mag(state_get_layer(input, 7));
    let g7 = bs_mag(state_get_layer(gamma, 7));
    let b7 = bs_mag(state_get_layer(beta, 7));
    let n7 = ((m7 - running_mean) / std) * g7 + b7;
    let result = state_set_layer(result, 7, bs_from_mag_clamped(n7));

    let m8 = bs_mag(state_get_layer(input, 8));
    let g8 = bs_mag(state_get_layer(gamma, 8));
    let b8 = bs_mag(state_get_layer(beta, 8));
    let n8 = ((m8 - running_mean) / std) * g8 + b8;
    let result = state_set_layer(result, 8, bs_from_mag_clamped(n8));

    let m9 = bs_mag(state_get_layer(input, 9));
    let g9 = bs_mag(state_get_layer(gamma, 9));
    let b9 = bs_mag(state_get_layer(beta, 9));
    let n9 = ((m9 - running_mean) / std) * g9 + b9;
    let result = state_set_layer(result, 9, bs_from_mag_clamped(n9));

    let m10 = bs_mag(state_get_layer(input, 10));
    let g10 = bs_mag(state_get_layer(gamma, 10));
    let b10 = bs_mag(state_get_layer(beta, 10));
    let n10 = ((m10 - running_mean) / std) * g10 + b10;
    let result = state_set_layer(result, 10, bs_from_mag_clamped(n10));

    let m11 = bs_mag(state_get_layer(input, 11));
    let g11 = bs_mag(state_get_layer(gamma, 11));
    let b11 = bs_mag(state_get_layer(beta, 11));
    let n11 = ((m11 - running_mean) / std) * g11 + b11;
    let result = state_set_layer(result, 11, bs_from_mag_clamped(n11));

    let m12 = bs_mag(state_get_layer(input, 12));
    let g12 = bs_mag(state_get_layer(gamma, 12));
    let b12 = bs_mag(state_get_layer(beta, 12));
    let n12 = ((m12 - running_mean) / std) * g12 + b12;
    let result = state_set_layer(result, 12, bs_from_mag_clamped(n12));

    let m13 = bs_mag(state_get_layer(input, 13));
    let g13 = bs_mag(state_get_layer(gamma, 13));
    let b13 = bs_mag(state_get_layer(beta, 13));
    let n13 = ((m13 - running_mean) / std) * g13 + b13;
    let result = state_set_layer(result, 13, bs_from_mag_clamped(n13));

    let m14 = bs_mag(state_get_layer(input, 14));
    let g14 = bs_mag(state_get_layer(gamma, 14));
    let b14 = bs_mag(state_get_layer(beta, 14));
    let n14 = ((m14 - running_mean) / std) * g14 + b14;
    let result = state_set_layer(result, 14, bs_from_mag_clamped(n14));

    let m15 = bs_mag(state_get_layer(input, 15));
    let g15 = bs_mag(state_get_layer(gamma, 15));
    let b15 = bs_mag(state_get_layer(beta, 15));
    let n15 = ((m15 - running_mean) / std) * g15 + b15;
    let result = state_set_layer(result, 15, bs_from_mag_clamped(n15));

    return result;
}

