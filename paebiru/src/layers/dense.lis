// Paebiru ML Library - Dense (Fully Connected) Layers
// Camadas densas com diferentes ativacoes

use core::bytesil::{bs_mag, bs_from_mag_clamped};
use core::activations::{relu_state, sigmoid_state, gelu_state};

// =============================================================================
// Dense Forward Pass
// =============================================================================

// Dense layer forward: output = activation(input * weights + bias)
pub fn dense_forward(input: State, weights: State, bias: State) -> State {
    let weighted = state_tensor(input, weights);
    let with_bias = state_xor(weighted, bias);
    return with_bias;
}

// Dense forward without bias
pub fn dense_no_bias(input: State, weights: State) -> State {
    return state_tensor(input, weights);
}

// =============================================================================
// Dense with Activations
// =============================================================================

// Dense forward with ReLU activation
pub fn dense_relu(input: State, weights: State, bias: State) -> State {
    let linear = dense_forward(input, weights, bias);
    return relu_state(linear);
}

// Dense forward with sigmoid activation
pub fn dense_sigmoid(input: State, weights: State, bias: State) -> State {
    let linear = dense_forward(input, weights, bias);
    return sigmoid_state(linear);
}

// Dense forward with GELU activation
pub fn dense_gelu(input: State, weights: State, bias: State) -> State {
    let linear = dense_forward(input, weights, bias);
    return gelu_state(linear);
}

// =============================================================================
// Weight Initialization
// =============================================================================

// Initialize weights with small values based on seed
pub fn init_weights(seed_f: Float) -> State {
    let result = state_vacuum();
    let base = seed_f - floor(seed_f / 16.0) * 16.0;

    let w0 = bytesil_new(0, floor(base));
    let result = state_set_layer(result, 0, w0);

    let t1 = base + 1.0;
    let t1 = t1 - floor(t1 / 16.0) * 16.0;
    let w1 = bytesil_new(0, floor(t1));
    let result = state_set_layer(result, 1, w1);

    let t2 = base + 2.0;
    let t2 = t2 - floor(t2 / 16.0) * 16.0;
    let w2 = bytesil_new(0, floor(t2));
    let result = state_set_layer(result, 2, w2);

    let t3 = base + 3.0;
    let t3 = t3 - floor(t3 / 16.0) * 16.0;
    let w3 = bytesil_new(0, floor(t3));
    let result = state_set_layer(result, 3, w3);

    let t4 = base + 4.0;
    let t4 = t4 - floor(t4 / 16.0) * 16.0;
    let w4 = bytesil_new(0, floor(t4));
    let result = state_set_layer(result, 4, w4);

    let t5 = base + 5.0;
    let t5 = t5 - floor(t5 / 16.0) * 16.0;
    let w5 = bytesil_new(0, floor(t5));
    let result = state_set_layer(result, 5, w5);

    let t6 = base + 6.0;
    let t6 = t6 - floor(t6 / 16.0) * 16.0;
    let w6 = bytesil_new(0, floor(t6));
    let result = state_set_layer(result, 6, w6);

    let t7 = base + 7.0;
    let t7 = t7 - floor(t7 / 16.0) * 16.0;
    let w7 = bytesil_new(0, floor(t7));
    let result = state_set_layer(result, 7, w7);

    let t8 = base + 8.0;
    let t8 = t8 - floor(t8 / 16.0) * 16.0;
    let w8 = bytesil_new(0, floor(t8));
    let result = state_set_layer(result, 8, w8);

    let t9 = base + 9.0;
    let t9 = t9 - floor(t9 / 16.0) * 16.0;
    let w9 = bytesil_new(0, floor(t9));
    let result = state_set_layer(result, 9, w9);

    let t10 = base + 10.0;
    let t10 = t10 - floor(t10 / 16.0) * 16.0;
    let w10 = bytesil_new(0, floor(t10));
    let result = state_set_layer(result, 10, w10);

    let t11 = base + 11.0;
    let t11 = t11 - floor(t11 / 16.0) * 16.0;
    let w11 = bytesil_new(0, floor(t11));
    let result = state_set_layer(result, 11, w11);

    let t12 = base + 12.0;
    let t12 = t12 - floor(t12 / 16.0) * 16.0;
    let w12 = bytesil_new(0, floor(t12));
    let result = state_set_layer(result, 12, w12);

    let t13 = base + 13.0;
    let t13 = t13 - floor(t13 / 16.0) * 16.0;
    let w13 = bytesil_new(0, floor(t13));
    let result = state_set_layer(result, 13, w13);

    let t14 = base + 14.0;
    let t14 = t14 - floor(t14 / 16.0) * 16.0;
    let w14 = bytesil_new(0, floor(t14));
    let result = state_set_layer(result, 14, w14);

    let t15 = base + 15.0;
    let t15 = t15 - floor(t15 / 16.0) * 16.0;
    let w15 = bytesil_new(0, floor(t15));
    let result = state_set_layer(result, 15, w15);

    return result;
}

// Zero bias initialization
pub fn init_bias_zero() -> State {
    return state_vacuum();
}

