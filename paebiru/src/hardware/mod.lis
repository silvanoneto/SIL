// Paebiru ML Library - Hardware Module
// Accelerator detection and capabilities

use core::bytesil::{bs_mag, bs_from_mag_clamped};

// =============================================================================
// Accelerator Types
// =============================================================================

pub fn ACCEL_NONE() -> Int { return 0; }
pub fn ACCEL_GPU() -> Int { return 1; }
pub fn ACCEL_TPU() -> Int { return 2; }
pub fn ACCEL_FPGA() -> Int { return 3; }
pub fn ACCEL_NEUROMORPHIC() -> Int { return 4; }
pub fn ACCEL_QUANTUM() -> Int { return 5; }

// =============================================================================
// Hardware Capabilities
// =============================================================================

// Capabilities state layout:
// Layer 0: accelerator type
// Layer 1: compute units (normalized)
// Layer 2: memory GB (normalized)
// Layer 3: bandwidth GB/s (normalized)
// Layer 4: supports fp16 flag
// Layer 5: supports int8 flag
// Layer 6: supports bf16 flag

// Create capabilities descriptor
pub fn capabilities_create(accel_type: Int, compute_units: Int,
                           memory_gb: Float, bandwidth_gbs: Float) -> State {
    let caps = state_vacuum();

    let caps = state_set_layer(caps, 0, bs_from_mag_clamped(float_from_int(accel_type) / 8.0));
    let caps = state_set_layer(caps, 1, bs_from_mag_clamped(float_from_int(compute_units) / 1024.0));
    let caps = state_set_layer(caps, 2, bs_from_mag_clamped(memory_gb / 256.0));
    let caps = state_set_layer(caps, 3, bs_from_mag_clamped(bandwidth_gbs / 2048.0));

    return caps;
}

// Set data type support flags
pub fn capabilities_set_dtypes(caps: State, fp16: Bool, int8: Bool, bf16: Bool) -> State {
    let f16 = 0.0; if fp16 { let f16 = 1.0; }
    let i8 = 0.0; if int8 { let i8 = 1.0; }
    let b16 = 0.0; if bf16 { let b16 = 1.0; }

    let caps = state_set_layer(caps, 4, bs_from_mag_clamped(f16));
    let caps = state_set_layer(caps, 5, bs_from_mag_clamped(i8));
    let caps = state_set_layer(caps, 6, bs_from_mag_clamped(b16));

    return caps;
}

// Extract capability fields
pub fn caps_accel_type(caps: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(caps, 0)) * 8.0);
}

pub fn caps_compute_units(caps: State) -> Int {
    return int_from_float(bs_mag(state_get_layer(caps, 1)) * 1024.0);
}

pub fn caps_memory_gb(caps: State) -> Float {
    return bs_mag(state_get_layer(caps, 2)) * 256.0;
}

pub fn caps_bandwidth_gbs(caps: State) -> Float {
    return bs_mag(state_get_layer(caps, 3)) * 2048.0;
}

pub fn caps_supports_fp16(caps: State) -> Bool {
    return bs_mag(state_get_layer(caps, 4)) > 0.5;
}

pub fn caps_supports_int8(caps: State) -> Bool {
    return bs_mag(state_get_layer(caps, 5)) > 0.5;
}

pub fn caps_supports_bf16(caps: State) -> Bool {
    return bs_mag(state_get_layer(caps, 6)) > 0.5;
}

// =============================================================================
// Accelerator Detection
// =============================================================================

// Detect available accelerators
// Returns capabilities of detected hardware
// Note: In SIL, we can only detect CPU; GPU/TPU require platform bindings
pub fn detect_accelerators() -> State {
    // Default to CPU capabilities
    let caps = capabilities_create(ACCEL_NONE(), 1, 16.0, 50.0);
    let caps = capabilities_set_dtypes(caps, true, true, false);
    return caps;
}

// Check if accelerator supports operation
pub fn supports_operation(caps: State, op_type: Int) -> Bool {
    let accel = caps_accel_type(caps);

    // Basic operations supported by all
    if op_type == 0 { return true; }  // MATMUL
    if op_type == 1 { return true; }  // CONV
    if op_type == 2 { return true; }  // RELU

    // Advanced operations
    if op_type == 3 {  // ATTENTION
        return accel >= ACCEL_GPU();
    }

    if op_type == 4 {  // SPARSE
        return accel == ACCEL_TPU() || accel == ACCEL_NEUROMORPHIC();
    }

    return false;
}

// Operation types
pub fn OP_MATMUL() -> Int { return 0; }
pub fn OP_CONV() -> Int { return 1; }
pub fn OP_RELU() -> Int { return 2; }
pub fn OP_ATTENTION() -> Int { return 3; }
pub fn OP_SPARSE() -> Int { return 4; }

// =============================================================================
// Performance Estimation
// =============================================================================

// Estimate FLOPS for operation
pub fn estimate_flops(caps: State, batch_size: Int, hidden_dim: Int) -> Float {
    let compute_units = float_from_int(caps_compute_units(caps));
    let base_flops = compute_units * 1e9;  // Assume 1 GFLOP per compute unit

    let ops = float_from_int(batch_size) * float_from_int(hidden_dim) * float_from_int(hidden_dim);
    return ops / base_flops;  // Returns estimated time
}

// Estimate memory usage
pub fn estimate_memory_mb(batch_size: Int, hidden_dim: Int, num_layers: Int) -> Float {
    // Each State is 16 bytes, estimate based on activations and weights
    let bytes_per_state = 16.0;
    let activations = float_from_int(batch_size * num_layers) * bytes_per_state;
    let weights = float_from_int(hidden_dim * hidden_dim * num_layers) * bytes_per_state;
    return (activations + weights) / (1024.0 * 1024.0);
}

// =============================================================================
// Default Configurations
// =============================================================================

// CPU configuration
pub fn caps_cpu_default() -> State {
    let caps = capabilities_create(ACCEL_NONE(), 8, 32.0, 50.0);
    return capabilities_set_dtypes(caps, true, true, false);
}

// GPU configuration (typical)
pub fn caps_gpu_default() -> State {
    let caps = capabilities_create(ACCEL_GPU(), 64, 16.0, 500.0);
    return capabilities_set_dtypes(caps, true, true, true);
}

// TPU configuration (typical)
pub fn caps_tpu_default() -> State {
    let caps = capabilities_create(ACCEL_TPU(), 128, 16.0, 900.0);
    return capabilities_set_dtypes(caps, true, true, true);
}

// Apple Neural Engine configuration
pub fn caps_ane_default() -> State {
    let caps = capabilities_create(ACCEL_NEUROMORPHIC(), 16, 8.0, 200.0);
    return capabilities_set_dtypes(caps, true, true, false);
}

