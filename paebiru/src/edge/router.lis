// Paebiru Edge Computing - Chromatic Router
// Roteia computacao baseado em complexidade e capacidades
//
// O router decide onde executar computacao baseado em:
// 1. Complexidade do State (rho_sil)
// 2. Dispositivos disponiveis e suas cargas
// 3. Restricoes de latencia e custo
// 4. Topologia de rede

use core::bytesil::{bs_mag};
use core::state::{st_sum_mag};
use edge::rho_sil::{rho_sil_fast};

// =============================================================================
// Route Decision Codes
// =============================================================================

pub fn ROUTE_LOCAL() -> Int { return 0; }
pub fn ROUTE_OFFLOAD_NEAR() -> Int { return 1; }
pub fn ROUTE_OFFLOAD_FAR() -> Int { return 2; }
pub fn ROUTE_SPLIT() -> Int { return 3; }

// =============================================================================
// Simple Routing
// =============================================================================

// Decisao de roteamento simples baseada em rho e capacidade local
pub fn route_simple(s: State, local_capability: Float) -> Int {
    let rho = rho_sil_fast(s);

    let local_threshold = 0.3 + 0.5 * local_capability;

    if rho <= local_threshold {
        return 0;  // ROUTE_LOCAL
    }

    if rho <= 0.6 {
        return 1;  // ROUTE_OFFLOAD_NEAR
    }

    return 2;  // ROUTE_OFFLOAD_FAR
}

// =============================================================================
// Load-Aware Routing
// =============================================================================

// Roteamento com consciencia de carga
pub fn route_load_aware(
    s: State,
    local_capability: Float,
    local_load: Float,
    near_load: Float,
    far_load: Float
) -> Int {
    let rho = rho_sil_fast(s);

    let local_threshold = (0.3 + 0.5 * local_capability) * (1.0 - 0.5 * local_load);
    let near_threshold = 0.6 * (1.0 - 0.3 * near_load);

    if rho <= local_threshold {
        return 0;  // ROUTE_LOCAL
    }

    if rho <= near_threshold {
        return 1;  // ROUTE_OFFLOAD_NEAR
    }

    if far_load > 0.9 {
        return 3;  // ROUTE_SPLIT
    }

    return 2;  // ROUTE_OFFLOAD_FAR
}

// =============================================================================
// Latency-Constrained Routing
// =============================================================================

// Roteamento com restricao de latencia
pub fn route_latency_constrained(
    s: State,
    local_capability: Float,
    max_latency_ms: Float
) -> Int {
    let rho = rho_sil_fast(s);

    let local_time = 10.0 * rho / max_float(local_capability, 0.1);

    if local_time <= max_latency_ms {
        return 0;  // ROUTE_LOCAL
    }

    let near_network_latency = 5.0;
    let far_network_latency = 50.0;

    let near_compute_time = 10.0 * rho / 0.5;
    let far_compute_time = 10.0 * rho / 0.9;

    if near_compute_time + near_network_latency <= max_latency_ms {
        return 1;  // ROUTE_OFFLOAD_NEAR
    }

    if far_compute_time + far_network_latency <= max_latency_ms {
        return 2;  // ROUTE_OFFLOAD_FAR
    }

    return 3;  // ROUTE_SPLIT
}

// =============================================================================
// Split Routing
// =============================================================================

// Determina razao de split para computacao distribuida
pub fn split_ratio(
    rho: Float,
    local_capability: Float,
    remote_capability: Float
) -> Float {
    let total_cap = local_capability + remote_capability + 0.0001;
    let local_ratio = local_capability / total_cap;

    let complexity_factor = 1.0 - rho;
    let adjusted_ratio = local_ratio * complexity_factor;

    return clamp_float(adjusted_ratio, 0.1, 0.9);
}

// Split state em duas partes
pub fn split_state_at(s: State, split_point: Int) -> State {
    let r = state_vacuum();

    if split_point > 0 {
        let r = state_set_layer(r, 0, state_get_layer(s, 0));
    }
    if split_point > 1 {
        let r = state_set_layer(r, 1, state_get_layer(s, 1));
    }
    if split_point > 2 {
        let r = state_set_layer(r, 2, state_get_layer(s, 2));
    }
    if split_point > 3 {
        let r = state_set_layer(r, 3, state_get_layer(s, 3));
    }
    if split_point > 4 {
        let r = state_set_layer(r, 4, state_get_layer(s, 4));
    }
    if split_point > 5 {
        let r = state_set_layer(r, 5, state_get_layer(s, 5));
    }
    if split_point > 6 {
        let r = state_set_layer(r, 6, state_get_layer(s, 6));
    }
    if split_point > 7 {
        let r = state_set_layer(r, 7, state_get_layer(s, 7));
    }
    if split_point > 8 {
        let r = state_set_layer(r, 8, state_get_layer(s, 8));
    }
    if split_point > 9 {
        let r = state_set_layer(r, 9, state_get_layer(s, 9));
    }
    if split_point > 10 {
        let r = state_set_layer(r, 10, state_get_layer(s, 10));
    }
    if split_point > 11 {
        let r = state_set_layer(r, 11, state_get_layer(s, 11));
    }
    if split_point > 12 {
        let r = state_set_layer(r, 12, state_get_layer(s, 12));
    }
    if split_point > 13 {
        let r = state_set_layer(r, 13, state_get_layer(s, 13));
    }
    if split_point > 14 {
        let r = state_set_layer(r, 14, state_get_layer(s, 14));
    }

    return r;
}

// Calcula ponto de split otimo
pub fn optimal_split_point(s: State, target_local_fraction: Float) -> Int {
    let total = st_sum_mag(s);
    let target = total * target_local_fraction;
    let cumsum = 0.0;

    let cumsum = cumsum + bs_mag(state_get_layer(s, 0));
    if cumsum >= target { return 1; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 1));
    if cumsum >= target { return 2; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 2));
    if cumsum >= target { return 3; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 3));
    if cumsum >= target { return 4; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 4));
    if cumsum >= target { return 5; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 5));
    if cumsum >= target { return 6; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 6));
    if cumsum >= target { return 7; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 7));
    if cumsum >= target { return 8; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 8));
    if cumsum >= target { return 9; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 9));
    if cumsum >= target { return 10; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 10));
    if cumsum >= target { return 11; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 11));
    if cumsum >= target { return 12; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 12));
    if cumsum >= target { return 13; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 13));
    if cumsum >= target { return 14; }
    let cumsum = cumsum + bs_mag(state_get_layer(s, 14));
    if cumsum >= target { return 15; }

    return 16;
}

// =============================================================================
// Merge Results
// =============================================================================

// Merge dois resultados split
pub fn merge_split_results(local_result: State, remote_result: State, split_point: Int) -> State {
    let r = state_vacuum();

    if split_point > 0 {
        let r = state_set_layer(r, 0, state_get_layer(local_result, 0));
    } else {
        let r = state_set_layer(r, 0, state_get_layer(remote_result, 0));
    }

    if split_point > 1 {
        let r = state_set_layer(r, 1, state_get_layer(local_result, 1));
    } else {
        let r = state_set_layer(r, 1, state_get_layer(remote_result, 1));
    }

    if split_point > 2 {
        let r = state_set_layer(r, 2, state_get_layer(local_result, 2));
    } else {
        let r = state_set_layer(r, 2, state_get_layer(remote_result, 2));
    }

    if split_point > 3 {
        let r = state_set_layer(r, 3, state_get_layer(local_result, 3));
    } else {
        let r = state_set_layer(r, 3, state_get_layer(remote_result, 3));
    }

    if split_point > 4 {
        let r = state_set_layer(r, 4, state_get_layer(local_result, 4));
    } else {
        let r = state_set_layer(r, 4, state_get_layer(remote_result, 4));
    }

    if split_point > 5 {
        let r = state_set_layer(r, 5, state_get_layer(local_result, 5));
    } else {
        let r = state_set_layer(r, 5, state_get_layer(remote_result, 5));
    }

    if split_point > 6 {
        let r = state_set_layer(r, 6, state_get_layer(local_result, 6));
    } else {
        let r = state_set_layer(r, 6, state_get_layer(remote_result, 6));
    }

    if split_point > 7 {
        let r = state_set_layer(r, 7, state_get_layer(local_result, 7));
    } else {
        let r = state_set_layer(r, 7, state_get_layer(remote_result, 7));
    }

    if split_point > 8 {
        let r = state_set_layer(r, 8, state_get_layer(local_result, 8));
    } else {
        let r = state_set_layer(r, 8, state_get_layer(remote_result, 8));
    }

    if split_point > 9 {
        let r = state_set_layer(r, 9, state_get_layer(local_result, 9));
    } else {
        let r = state_set_layer(r, 9, state_get_layer(remote_result, 9));
    }

    if split_point > 10 {
        let r = state_set_layer(r, 10, state_get_layer(local_result, 10));
    } else {
        let r = state_set_layer(r, 10, state_get_layer(remote_result, 10));
    }

    if split_point > 11 {
        let r = state_set_layer(r, 11, state_get_layer(local_result, 11));
    } else {
        let r = state_set_layer(r, 11, state_get_layer(remote_result, 11));
    }

    if split_point > 12 {
        let r = state_set_layer(r, 12, state_get_layer(local_result, 12));
    } else {
        let r = state_set_layer(r, 12, state_get_layer(remote_result, 12));
    }

    if split_point > 13 {
        let r = state_set_layer(r, 13, state_get_layer(local_result, 13));
    } else {
        let r = state_set_layer(r, 13, state_get_layer(remote_result, 13));
    }

    if split_point > 14 {
        let r = state_set_layer(r, 14, state_get_layer(local_result, 14));
    } else {
        let r = state_set_layer(r, 14, state_get_layer(remote_result, 14));
    }

    if split_point > 15 {
        let r = state_set_layer(r, 15, state_get_layer(local_result, 15));
    } else {
        let r = state_set_layer(r, 15, state_get_layer(remote_result, 15));
    }

    return r;
}

// =============================================================================
// Priority and Scheduling
// =============================================================================

// Compute priority score for routing
pub fn compute_priority(rho: Float, deadline_ms: Float, current_time_ms: Float) -> Float {
    let time_remaining = deadline_ms - current_time_ms;
    let urgency = 1.0 / max_float(time_remaining, 1.0);

    return rho * 0.3 + urgency * 100.0 * 0.7;
}

// Should preempt current task?
pub fn should_preempt(
    current_priority: Float,
    new_priority: Float,
    current_progress: Float
) -> Bool {
    if current_progress > 0.8 {
        return false;
    }

    return new_priority > current_priority * 1.5;
}

