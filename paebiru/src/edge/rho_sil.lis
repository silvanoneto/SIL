// Paebiru Edge Computing - rho_Sil Complexity Metric
// Mede complexidade computacional de State para decisoes de roteamento
//
// A metrica rho_Sil combina:
// 1. Contagem de transicoes: mudancas significativas entre camadas adjacentes
// 2. Entropia de informacao: distribuicao de magnitudes
// 3. Coerencia de fase: alinhamento de fases entre camadas
//
// Valores rho maiores indicam estados mais complexos que precisam mais compute

use core::bytesil::{bs_mag, EPSILON};
use core::state::{st_sum_mag, st_sum_mag_sq};

// =============================================================================
// Basic Metrics
// =============================================================================

// Conta transicoes significativas entre camadas adjacentes
pub fn transition_count(s: State, threshold: Float) -> Float {
    let count = 0.0;

    let m0 = bs_mag(state_get_layer(s, 0));
    let m1 = bs_mag(state_get_layer(s, 1));
    if abs_float(m1 - m0) > threshold {
        let count = count + 1.0;
    }

    let m2 = bs_mag(state_get_layer(s, 2));
    if abs_float(m2 - m1) > threshold {
        let count = count + 1.0;
    }

    let m3 = bs_mag(state_get_layer(s, 3));
    if abs_float(m3 - m2) > threshold {
        let count = count + 1.0;
    }

    let m4 = bs_mag(state_get_layer(s, 4));
    if abs_float(m4 - m3) > threshold {
        let count = count + 1.0;
    }

    let m5 = bs_mag(state_get_layer(s, 5));
    if abs_float(m5 - m4) > threshold {
        let count = count + 1.0;
    }

    let m6 = bs_mag(state_get_layer(s, 6));
    if abs_float(m6 - m5) > threshold {
        let count = count + 1.0;
    }

    let m7 = bs_mag(state_get_layer(s, 7));
    if abs_float(m7 - m6) > threshold {
        let count = count + 1.0;
    }

    let m8 = bs_mag(state_get_layer(s, 8));
    if abs_float(m8 - m7) > threshold {
        let count = count + 1.0;
    }

    let m9 = bs_mag(state_get_layer(s, 9));
    if abs_float(m9 - m8) > threshold {
        let count = count + 1.0;
    }

    let m10 = bs_mag(state_get_layer(s, 10));
    if abs_float(m10 - m9) > threshold {
        let count = count + 1.0;
    }

    let m11 = bs_mag(state_get_layer(s, 11));
    if abs_float(m11 - m10) > threshold {
        let count = count + 1.0;
    }

    let m12 = bs_mag(state_get_layer(s, 12));
    if abs_float(m12 - m11) > threshold {
        let count = count + 1.0;
    }

    let m13 = bs_mag(state_get_layer(s, 13));
    if abs_float(m13 - m12) > threshold {
        let count = count + 1.0;
    }

    let m14 = bs_mag(state_get_layer(s, 14));
    if abs_float(m14 - m13) > threshold {
        let count = count + 1.0;
    }

    let m15 = bs_mag(state_get_layer(s, 15));
    if abs_float(m15 - m14) > threshold {
        let count = count + 1.0;
    }

    return count;
}

// =============================================================================
// Entropy
// =============================================================================

// Entropia de informacao da distribuicao de magnitudes
pub fn magnitude_entropy(s: State) -> Float {
    let total = st_sum_mag(s) + EPSILON();

    let entropy = 0.0;

    let p0 = bs_mag(state_get_layer(s, 0)) / total;
    if p0 > EPSILON() {
        let entropy = entropy - p0 * ln(p0);
    }

    let p1 = bs_mag(state_get_layer(s, 1)) / total;
    if p1 > EPSILON() {
        let entropy = entropy - p1 * ln(p1);
    }

    let p2 = bs_mag(state_get_layer(s, 2)) / total;
    if p2 > EPSILON() {
        let entropy = entropy - p2 * ln(p2);
    }

    let p3 = bs_mag(state_get_layer(s, 3)) / total;
    if p3 > EPSILON() {
        let entropy = entropy - p3 * ln(p3);
    }

    let p4 = bs_mag(state_get_layer(s, 4)) / total;
    if p4 > EPSILON() {
        let entropy = entropy - p4 * ln(p4);
    }

    let p5 = bs_mag(state_get_layer(s, 5)) / total;
    if p5 > EPSILON() {
        let entropy = entropy - p5 * ln(p5);
    }

    let p6 = bs_mag(state_get_layer(s, 6)) / total;
    if p6 > EPSILON() {
        let entropy = entropy - p6 * ln(p6);
    }

    let p7 = bs_mag(state_get_layer(s, 7)) / total;
    if p7 > EPSILON() {
        let entropy = entropy - p7 * ln(p7);
    }

    let p8 = bs_mag(state_get_layer(s, 8)) / total;
    if p8 > EPSILON() {
        let entropy = entropy - p8 * ln(p8);
    }

    let p9 = bs_mag(state_get_layer(s, 9)) / total;
    if p9 > EPSILON() {
        let entropy = entropy - p9 * ln(p9);
    }

    let p10 = bs_mag(state_get_layer(s, 10)) / total;
    if p10 > EPSILON() {
        let entropy = entropy - p10 * ln(p10);
    }

    let p11 = bs_mag(state_get_layer(s, 11)) / total;
    if p11 > EPSILON() {
        let entropy = entropy - p11 * ln(p11);
    }

    let p12 = bs_mag(state_get_layer(s, 12)) / total;
    if p12 > EPSILON() {
        let entropy = entropy - p12 * ln(p12);
    }

    let p13 = bs_mag(state_get_layer(s, 13)) / total;
    if p13 > EPSILON() {
        let entropy = entropy - p13 * ln(p13);
    }

    let p14 = bs_mag(state_get_layer(s, 14)) / total;
    if p14 > EPSILON() {
        let entropy = entropy - p14 * ln(p14);
    }

    let p15 = bs_mag(state_get_layer(s, 15)) / total;
    if p15 > EPSILON() {
        let entropy = entropy - p15 * ln(p15);
    }

    return entropy;
}

// =============================================================================
// Phase Coherence
// =============================================================================

// Coerencia de fase: mede alinhamento das fases
pub fn phase_coherence(s: State) -> Float {
    let sum_sin = 0.0;
    let sum_cos = 0.0;

    let ph0 = bytesil_phase_radians(state_get_layer(s, 0));
    let sum_sin = sum_sin + sin(ph0);
    let sum_cos = sum_cos + cos(ph0);

    let ph1 = bytesil_phase_radians(state_get_layer(s, 1));
    let sum_sin = sum_sin + sin(ph1);
    let sum_cos = sum_cos + cos(ph1);

    let ph2 = bytesil_phase_radians(state_get_layer(s, 2));
    let sum_sin = sum_sin + sin(ph2);
    let sum_cos = sum_cos + cos(ph2);

    let ph3 = bytesil_phase_radians(state_get_layer(s, 3));
    let sum_sin = sum_sin + sin(ph3);
    let sum_cos = sum_cos + cos(ph3);

    let ph4 = bytesil_phase_radians(state_get_layer(s, 4));
    let sum_sin = sum_sin + sin(ph4);
    let sum_cos = sum_cos + cos(ph4);

    let ph5 = bytesil_phase_radians(state_get_layer(s, 5));
    let sum_sin = sum_sin + sin(ph5);
    let sum_cos = sum_cos + cos(ph5);

    let ph6 = bytesil_phase_radians(state_get_layer(s, 6));
    let sum_sin = sum_sin + sin(ph6);
    let sum_cos = sum_cos + cos(ph6);

    let ph7 = bytesil_phase_radians(state_get_layer(s, 7));
    let sum_sin = sum_sin + sin(ph7);
    let sum_cos = sum_cos + cos(ph7);

    let ph8 = bytesil_phase_radians(state_get_layer(s, 8));
    let sum_sin = sum_sin + sin(ph8);
    let sum_cos = sum_cos + cos(ph8);

    let ph9 = bytesil_phase_radians(state_get_layer(s, 9));
    let sum_sin = sum_sin + sin(ph9);
    let sum_cos = sum_cos + cos(ph9);

    let ph10 = bytesil_phase_radians(state_get_layer(s, 10));
    let sum_sin = sum_sin + sin(ph10);
    let sum_cos = sum_cos + cos(ph10);

    let ph11 = bytesil_phase_radians(state_get_layer(s, 11));
    let sum_sin = sum_sin + sin(ph11);
    let sum_cos = sum_cos + cos(ph11);

    let ph12 = bytesil_phase_radians(state_get_layer(s, 12));
    let sum_sin = sum_sin + sin(ph12);
    let sum_cos = sum_cos + cos(ph12);

    let ph13 = bytesil_phase_radians(state_get_layer(s, 13));
    let sum_sin = sum_sin + sin(ph13);
    let sum_cos = sum_cos + cos(ph13);

    let ph14 = bytesil_phase_radians(state_get_layer(s, 14));
    let sum_sin = sum_sin + sin(ph14);
    let sum_cos = sum_cos + cos(ph14);

    let ph15 = bytesil_phase_radians(state_get_layer(s, 15));
    let sum_sin = sum_sin + sin(ph15);
    let sum_cos = sum_cos + cos(ph15);

    let mean_sin = sum_sin / 16.0;
    let mean_cos = sum_cos / 16.0;

    return sqrt(mean_sin * mean_sin + mean_cos * mean_cos);
}

// =============================================================================
// rho_Sil Metric
// =============================================================================

// rho_Sil: Metrica de complexidade principal
pub fn rho_sil(s: State) -> Float {
    let threshold = 0.1;

    // Componente de transicoes (0-15, normalizado para 0-1)
    let trans = transition_count(s, threshold) / 15.0;

    // Componente de entropia (0 a ln(16) ~= 2.77, normalizado para 0-1)
    let ent = magnitude_entropy(s) / 2.77;

    // Componente de incoerencia (1 - coerencia, 0-1)
    let incoh = 1.0 - phase_coherence(s);

    // Componente de magnitude (escala log, normalizado)
    let sq_sum = st_sum_mag_sq(s);
    let mag = ln(sqrt(sq_sum) + 1.0) / 4.0;

    // Combinacao ponderada
    let rho = 0.35 * trans + 0.35 * ent + 0.15 * incoh + 0.15 * mag;

    return clamp_float(rho, 0.0, 1.0);
}

// rho simplificado (mais rapido de calcular)
pub fn rho_sil_fast(s: State) -> Float {
    let threshold = 0.1;
    let trans = transition_count(s, threshold) / 15.0;
    let ent = magnitude_entropy(s) / 2.77;
    return clamp_float(0.5 * trans + 0.5 * ent, 0.0, 1.0);
}

// =============================================================================
// Offloading Decisions
// =============================================================================

// Verifica se deve offload para dispositivo mais potente
pub fn should_offload(rho: Float, rho_critical: Float) -> Bool {
    return rho > rho_critical;
}

// Threshold critico dinamico baseado em capacidade
pub fn rho_critical_dynamic(capability: Float, load_factor: Float) -> Float {
    let base = 0.3 + 0.5 * capability;
    let adjusted = base * (1.0 - 0.3 * load_factor);
    return clamp_float(adjusted, 0.1, 0.9);
}

// =============================================================================
// Estimativas
// =============================================================================

// FLOPS estimados baseado em rho
pub fn estimated_flops(rho: Float, base_flops: Float) -> Float {
    return base_flops * exp(2.0 * rho);
}

// Estimativa de energia
pub fn energy_estimate(rho: Float, base_energy: Float) -> Float {
    return base_energy * (1.0 + rho * rho);
}

// Estimativa de latencia em ms
pub fn latency_estimate(rho: Float, base_latency_ms: Float) -> Float {
    return base_latency_ms * (1.0 + 2.0 * rho);
}

// Delta de complexidade entre dois estados
pub fn rho_delta(s1: State, s2: State) -> Float {
    let rho1 = rho_sil(s1);
    let rho2 = rho_sil(s2);
    return rho2 - rho1;
}

// Media movel de rho
pub fn rho_moving_avg(prev_avg: Float, new_rho: Float, alpha: Float) -> Float {
    return alpha * new_rho + (1.0 - alpha) * prev_avg;
}

