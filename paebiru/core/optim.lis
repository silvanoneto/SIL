// Paebiru ML Library - Optimizers

fn scale_st(s: State, scalar: Float) -> State {
    let r = state_vacuum();
    let r = state_set_layer(r, 0, complex_scale(state_get_layer(s, 0), scalar));
    let r = state_set_layer(r, 1, complex_scale(state_get_layer(s, 1), scalar));
    let r = state_set_layer(r, 2, complex_scale(state_get_layer(s, 2), scalar));
    let r = state_set_layer(r, 3, complex_scale(state_get_layer(s, 3), scalar));
    let r = state_set_layer(r, 4, complex_scale(state_get_layer(s, 4), scalar));
    let r = state_set_layer(r, 5, complex_scale(state_get_layer(s, 5), scalar));
    let r = state_set_layer(r, 6, complex_scale(state_get_layer(s, 6), scalar));
    let r = state_set_layer(r, 7, complex_scale(state_get_layer(s, 7), scalar));
    let r = state_set_layer(r, 8, complex_scale(state_get_layer(s, 8), scalar));
    let r = state_set_layer(r, 9, complex_scale(state_get_layer(s, 9), scalar));
    let r = state_set_layer(r, 10, complex_scale(state_get_layer(s, 10), scalar));
    let r = state_set_layer(r, 11, complex_scale(state_get_layer(s, 11), scalar));
    let r = state_set_layer(r, 12, complex_scale(state_get_layer(s, 12), scalar));
    let r = state_set_layer(r, 13, complex_scale(state_get_layer(s, 13), scalar));
    let r = state_set_layer(r, 14, complex_scale(state_get_layer(s, 14), scalar));
    let r = state_set_layer(r, 15, complex_scale(state_get_layer(s, 15), scalar));
    return r;
}

fn sub_st(a: State, b: State) -> State {
    let r = state_vacuum();
    let r = state_set_layer(r, 0, complex_sub(state_get_layer(a, 0), state_get_layer(b, 0)));
    let r = state_set_layer(r, 1, complex_sub(state_get_layer(a, 1), state_get_layer(b, 1)));
    let r = state_set_layer(r, 2, complex_sub(state_get_layer(a, 2), state_get_layer(b, 2)));
    let r = state_set_layer(r, 3, complex_sub(state_get_layer(a, 3), state_get_layer(b, 3)));
    let r = state_set_layer(r, 4, complex_sub(state_get_layer(a, 4), state_get_layer(b, 4)));
    let r = state_set_layer(r, 5, complex_sub(state_get_layer(a, 5), state_get_layer(b, 5)));
    let r = state_set_layer(r, 6, complex_sub(state_get_layer(a, 6), state_get_layer(b, 6)));
    let r = state_set_layer(r, 7, complex_sub(state_get_layer(a, 7), state_get_layer(b, 7)));
    let r = state_set_layer(r, 8, complex_sub(state_get_layer(a, 8), state_get_layer(b, 8)));
    let r = state_set_layer(r, 9, complex_sub(state_get_layer(a, 9), state_get_layer(b, 9)));
    let r = state_set_layer(r, 10, complex_sub(state_get_layer(a, 10), state_get_layer(b, 10)));
    let r = state_set_layer(r, 11, complex_sub(state_get_layer(a, 11), state_get_layer(b, 11)));
    let r = state_set_layer(r, 12, complex_sub(state_get_layer(a, 12), state_get_layer(b, 12)));
    let r = state_set_layer(r, 13, complex_sub(state_get_layer(a, 13), state_get_layer(b, 13)));
    let r = state_set_layer(r, 14, complex_sub(state_get_layer(a, 14), state_get_layer(b, 14)));
    let r = state_set_layer(r, 15, complex_sub(state_get_layer(a, 15), state_get_layer(b, 15)));
    return r;
}

fn add_st(a: State, b: State) -> State {
    let r = state_vacuum();
    let r = state_set_layer(r, 0, complex_add(state_get_layer(a, 0), state_get_layer(b, 0)));
    let r = state_set_layer(r, 1, complex_add(state_get_layer(a, 1), state_get_layer(b, 1)));
    let r = state_set_layer(r, 2, complex_add(state_get_layer(a, 2), state_get_layer(b, 2)));
    let r = state_set_layer(r, 3, complex_add(state_get_layer(a, 3), state_get_layer(b, 3)));
    let r = state_set_layer(r, 4, complex_add(state_get_layer(a, 4), state_get_layer(b, 4)));
    let r = state_set_layer(r, 5, complex_add(state_get_layer(a, 5), state_get_layer(b, 5)));
    let r = state_set_layer(r, 6, complex_add(state_get_layer(a, 6), state_get_layer(b, 6)));
    let r = state_set_layer(r, 7, complex_add(state_get_layer(a, 7), state_get_layer(b, 7)));
    let r = state_set_layer(r, 8, complex_add(state_get_layer(a, 8), state_get_layer(b, 8)));
    let r = state_set_layer(r, 9, complex_add(state_get_layer(a, 9), state_get_layer(b, 9)));
    let r = state_set_layer(r, 10, complex_add(state_get_layer(a, 10), state_get_layer(b, 10)));
    let r = state_set_layer(r, 11, complex_add(state_get_layer(a, 11), state_get_layer(b, 11)));
    let r = state_set_layer(r, 12, complex_add(state_get_layer(a, 12), state_get_layer(b, 12)));
    let r = state_set_layer(r, 13, complex_add(state_get_layer(a, 13), state_get_layer(b, 13)));
    let r = state_set_layer(r, 14, complex_add(state_get_layer(a, 14), state_get_layer(b, 14)));
    let r = state_set_layer(r, 15, complex_add(state_get_layer(a, 15), state_get_layer(b, 15)));
    return r;
}

fn sgd_step(params: State, gradients: State, lr: Float) -> State {
    let scaled_grad = scale_st(gradients, lr);
    return sub_st(params, scaled_grad);
}

fn sgd_momentum_velocity(velocity: State, gradients: State, lr: Float, momentum: Float) -> State {
    let v_momentum = scale_st(velocity, momentum);
    let grad_scaled = scale_st(gradients, lr);
    return sub_st(v_momentum, grad_scaled);
}

fn sgd_momentum_step(params: State, velocity: State) -> State {
    return add_st(params, velocity);
}

fn norm_l2(s: State) -> Float {
    let sum = 0.0;
    let sum = sum + bytesil_magnitude(state_get_layer(s, 0)) * bytesil_magnitude(state_get_layer(s, 0));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 1)) * bytesil_magnitude(state_get_layer(s, 1));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 2)) * bytesil_magnitude(state_get_layer(s, 2));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 3)) * bytesil_magnitude(state_get_layer(s, 3));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 4)) * bytesil_magnitude(state_get_layer(s, 4));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 5)) * bytesil_magnitude(state_get_layer(s, 5));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 6)) * bytesil_magnitude(state_get_layer(s, 6));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 7)) * bytesil_magnitude(state_get_layer(s, 7));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 8)) * bytesil_magnitude(state_get_layer(s, 8));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 9)) * bytesil_magnitude(state_get_layer(s, 9));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 10)) * bytesil_magnitude(state_get_layer(s, 10));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 11)) * bytesil_magnitude(state_get_layer(s, 11));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 12)) * bytesil_magnitude(state_get_layer(s, 12));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 13)) * bytesil_magnitude(state_get_layer(s, 13));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 14)) * bytesil_magnitude(state_get_layer(s, 14));
    let sum = sum + bytesil_magnitude(state_get_layer(s, 15)) * bytesil_magnitude(state_get_layer(s, 15));
    return sqrt(sum);
}

fn clip_grad_norm(gradients: State, max_norm: Float) -> State {
    let norm = norm_l2(gradients);
    if norm > max_norm {
        return scale_st(gradients, max_norm / norm);
    }
    return gradients;
}

fn lr_constant(initial_lr: Float) -> Float {
    return initial_lr;
}

fn lr_cosine_annealing(initial_lr: Float, step: Int, total_steps: Int, min_lr: Float) -> Float {
    let progress = step * 1.0 / total_steps * 1.0;
    let cos_val = cos(pi() * progress);
    return min_lr + 0.5 * (initial_lr - min_lr) * (1.0 + cos_val);
}

fn lr_warmup(target_lr: Float, step: Int, warmup_steps: Int) -> Float {
    if step >= warmup_steps {
        return target_lr;
    }
    return target_lr * (step * 1.0 / warmup_steps * 1.0);
}

fn lr_step_decay(initial_lr: Float, step: Int, step_size: Int, gamma: Float) -> Float {
    let num_decays = step / step_size;
    return initial_lr * pow_float(gamma, num_decays * 1.0);
}

fn xavier_scale(fan_in: Int, fan_out: Int) -> Float {
    return sqrt(6.0 / (fan_in * 1.0 + fan_out * 1.0));
}

fn he_scale(fan_in: Int) -> Float {
    return sqrt(2.0 / (fan_in * 1.0));
}
