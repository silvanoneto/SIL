// Dropout layer implementation
// Uses deterministic masking based on seed for reproducibility
// During training, randomly zeros elements with probability p
// During inference, passes through unchanged

// Simple hash function without modulo operator
// Uses floor/frac approach: hash = frac(seed * large_prime) where frac(x) = x - floor(x)
fn simple_hash(seed: Float) -> Float {
    let x = seed * 0.6180339887;
    return x - floor(x);
}

// Dropout with seed-based pseudo-random mask
// input: State to apply dropout to
// p: dropout probability (0.0 to 1.0) - fraction to drop
// training: Bool - if false, returns input unchanged
// seed_f: Float - random seed for reproducibility
fn dropout(input: State, p: Float, training: Bool, seed_f: Float) -> State {
    // During inference, return input unchanged
    if training == false {
        return input;
    }

    // Scale factor for inverted dropout (keeps expected value same)
    let scale = 1.0 / (1.0 - p);

    // Generate pseudo-random mask based on seed
    let result = state_vacuum();

    // Layer 0
    let keep0 = simple_hash(seed_f + 0.1);
    let v0 = state_get_layer(input, 0);
    if keep0 > p {
        let m0 = bytesil_magnitude(v0) * scale;
        let r0 = bytesil_new(floor(clamp_float(ln(max_float(m0, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 0, r0);
    }

    // Layer 1
    let keep1 = simple_hash(seed_f + 1.1);
    let v1 = state_get_layer(input, 1);
    if keep1 > p {
        let m1 = bytesil_magnitude(v1) * scale;
        let r1 = bytesil_new(floor(clamp_float(ln(max_float(m1, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 1, r1);
    }

    // Layer 2
    let keep2 = simple_hash(seed_f + 2.1);
    let v2 = state_get_layer(input, 2);
    if keep2 > p {
        let m2 = bytesil_magnitude(v2) * scale;
        let r2 = bytesil_new(floor(clamp_float(ln(max_float(m2, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 2, r2);
    }

    // Layer 3
    let keep3 = simple_hash(seed_f + 3.1);
    let v3 = state_get_layer(input, 3);
    if keep3 > p {
        let m3 = bytesil_magnitude(v3) * scale;
        let r3 = bytesil_new(floor(clamp_float(ln(max_float(m3, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 3, r3);
    }

    // Layer 4
    let keep4 = simple_hash(seed_f + 4.1);
    let v4 = state_get_layer(input, 4);
    if keep4 > p {
        let m4 = bytesil_magnitude(v4) * scale;
        let r4 = bytesil_new(floor(clamp_float(ln(max_float(m4, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 4, r4);
    }

    // Layer 5
    let keep5 = simple_hash(seed_f + 5.1);
    let v5 = state_get_layer(input, 5);
    if keep5 > p {
        let m5 = bytesil_magnitude(v5) * scale;
        let r5 = bytesil_new(floor(clamp_float(ln(max_float(m5, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 5, r5);
    }

    // Layer 6
    let keep6 = simple_hash(seed_f + 6.1);
    let v6 = state_get_layer(input, 6);
    if keep6 > p {
        let m6 = bytesil_magnitude(v6) * scale;
        let r6 = bytesil_new(floor(clamp_float(ln(max_float(m6, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 6, r6);
    }

    // Layer 7
    let keep7 = simple_hash(seed_f + 7.1);
    let v7 = state_get_layer(input, 7);
    if keep7 > p {
        let m7 = bytesil_magnitude(v7) * scale;
        let r7 = bytesil_new(floor(clamp_float(ln(max_float(m7, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 7, r7);
    }

    // Layer 8
    let keep8 = simple_hash(seed_f + 8.1);
    let v8 = state_get_layer(input, 8);
    if keep8 > p {
        let m8 = bytesil_magnitude(v8) * scale;
        let r8 = bytesil_new(floor(clamp_float(ln(max_float(m8, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 8, r8);
    }

    // Layer 9
    let keep9 = simple_hash(seed_f + 9.1);
    let v9 = state_get_layer(input, 9);
    if keep9 > p {
        let m9 = bytesil_magnitude(v9) * scale;
        let r9 = bytesil_new(floor(clamp_float(ln(max_float(m9, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 9, r9);
    }

    // Layer 10
    let keep10 = simple_hash(seed_f + 10.1);
    let v10 = state_get_layer(input, 10);
    if keep10 > p {
        let m10 = bytesil_magnitude(v10) * scale;
        let r10 = bytesil_new(floor(clamp_float(ln(max_float(m10, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 10, r10);
    }

    // Layer 11
    let keep11 = simple_hash(seed_f + 11.1);
    let v11 = state_get_layer(input, 11);
    if keep11 > p {
        let m11 = bytesil_magnitude(v11) * scale;
        let r11 = bytesil_new(floor(clamp_float(ln(max_float(m11, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 11, r11);
    }

    // Layer 12
    let keep12 = simple_hash(seed_f + 12.1);
    let v12 = state_get_layer(input, 12);
    if keep12 > p {
        let m12 = bytesil_magnitude(v12) * scale;
        let r12 = bytesil_new(floor(clamp_float(ln(max_float(m12, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 12, r12);
    }

    // Layer 13
    let keep13 = simple_hash(seed_f + 13.1);
    let v13 = state_get_layer(input, 13);
    if keep13 > p {
        let m13 = bytesil_magnitude(v13) * scale;
        let r13 = bytesil_new(floor(clamp_float(ln(max_float(m13, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 13, r13);
    }

    // Layer 14
    let keep14 = simple_hash(seed_f + 14.1);
    let v14 = state_get_layer(input, 14);
    if keep14 > p {
        let m14 = bytesil_magnitude(v14) * scale;
        let r14 = bytesil_new(floor(clamp_float(ln(max_float(m14, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 14, r14);
    }

    // Layer 15
    let keep15 = simple_hash(seed_f + 15.1);
    let v15 = state_get_layer(input, 15);
    if keep15 > p {
        let m15 = bytesil_magnitude(v15) * scale;
        let r15 = bytesil_new(floor(clamp_float(ln(max_float(m15, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 15, r15);
    }

    return result;
}

// Simplified dropout that always applies (for training only use)
fn dropout_training(input: State, p: Float, seed_f: Float) -> State {
    return dropout(input, p, true, seed_f);
}

// DropConnect variant - drops weights instead of activations
fn dropconnect(weights: State, p: Float, seed_f: Float) -> State {
    return dropout(weights, p, true, seed_f);
}

// Spatial dropout - drops entire channels (groups of 4)
fn spatial_dropout_4(input: State, p: Float, seed_f: Float) -> State {
    let result = state_vacuum();
    let scale = 1.0 / (1.0 - p);

    // Channel 0 (L0-L3)
    let keep0 = simple_hash(seed_f + 0.5);
    if keep0 > p {
        let v0 = state_get_layer(input, 0);
        let m0 = bytesil_magnitude(v0) * scale;
        let r0 = bytesil_new(floor(clamp_float(ln(max_float(m0, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 0, r0);

        let v1 = state_get_layer(input, 1);
        let m1 = bytesil_magnitude(v1) * scale;
        let r1 = bytesil_new(floor(clamp_float(ln(max_float(m1, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 1, r1);

        let v2 = state_get_layer(input, 2);
        let m2 = bytesil_magnitude(v2) * scale;
        let r2 = bytesil_new(floor(clamp_float(ln(max_float(m2, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 2, r2);

        let v3 = state_get_layer(input, 3);
        let m3 = bytesil_magnitude(v3) * scale;
        let r3 = bytesil_new(floor(clamp_float(ln(max_float(m3, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 3, r3);
    }

    // Channel 1 (L4-L7)
    let keep1 = simple_hash(seed_f + 1.5);
    if keep1 > p {
        let v4 = state_get_layer(input, 4);
        let m4 = bytesil_magnitude(v4) * scale;
        let r4 = bytesil_new(floor(clamp_float(ln(max_float(m4, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 4, r4);

        let v5 = state_get_layer(input, 5);
        let m5 = bytesil_magnitude(v5) * scale;
        let r5 = bytesil_new(floor(clamp_float(ln(max_float(m5, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 5, r5);

        let v6 = state_get_layer(input, 6);
        let m6 = bytesil_magnitude(v6) * scale;
        let r6 = bytesil_new(floor(clamp_float(ln(max_float(m6, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 6, r6);

        let v7 = state_get_layer(input, 7);
        let m7 = bytesil_magnitude(v7) * scale;
        let r7 = bytesil_new(floor(clamp_float(ln(max_float(m7, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 7, r7);
    }

    // Channel 2 (L8-L11)
    let keep2 = simple_hash(seed_f + 2.5);
    if keep2 > p {
        let v8 = state_get_layer(input, 8);
        let m8 = bytesil_magnitude(v8) * scale;
        let r8 = bytesil_new(floor(clamp_float(ln(max_float(m8, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 8, r8);

        let v9 = state_get_layer(input, 9);
        let m9 = bytesil_magnitude(v9) * scale;
        let r9 = bytesil_new(floor(clamp_float(ln(max_float(m9, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 9, r9);

        let v10 = state_get_layer(input, 10);
        let m10 = bytesil_magnitude(v10) * scale;
        let r10 = bytesil_new(floor(clamp_float(ln(max_float(m10, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 10, r10);

        let v11 = state_get_layer(input, 11);
        let m11 = bytesil_magnitude(v11) * scale;
        let r11 = bytesil_new(floor(clamp_float(ln(max_float(m11, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 11, r11);
    }

    // Channel 3 (L12-L15)
    let keep3 = simple_hash(seed_f + 3.5);
    if keep3 > p {
        let v12 = state_get_layer(input, 12);
        let m12 = bytesil_magnitude(v12) * scale;
        let r12 = bytesil_new(floor(clamp_float(ln(max_float(m12, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 12, r12);

        let v13 = state_get_layer(input, 13);
        let m13 = bytesil_magnitude(v13) * scale;
        let r13 = bytesil_new(floor(clamp_float(ln(max_float(m13, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 13, r13);

        let v14 = state_get_layer(input, 14);
        let m14 = bytesil_magnitude(v14) * scale;
        let r14 = bytesil_new(floor(clamp_float(ln(max_float(m14, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 14, r14);

        let v15 = state_get_layer(input, 15);
        let m15 = bytesil_magnitude(v15) * scale;
        let r15 = bytesil_new(floor(clamp_float(ln(max_float(m15, 0.0001)), -8.0, 7.0)), 0);
        let result = state_set_layer(result, 15, r15);
    }

    return result;
}

// Identity function - returns input unchanged (for inference mode)
fn dropout_inference(input: State) -> State {
    return input;
}
