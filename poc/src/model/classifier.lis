// PoC - Classificador Neural
// Rede densa de 2 camadas para classificação de 16 classes de gestos

use paebiru::core::bytesil::{bs_mag, bs_from_mag_clamped, bs_zero};
use paebiru::core::state::{st_vacuum, st_set, st_get, st_add, st_sub, st_scale, st_xor, st_tensor};
use paebiru::core::activations::{relu_state, softmax};
use paebiru::layers::dense::{dense_forward, dense_relu, init_weights, init_bias_zero};

// =============================================================================
// Estrutura do Modelo
// =============================================================================

// Modelo: 2 camadas dense (16->16->16)
// Layout dos pesos (empacotados em States):
//   weights1: State para pesos da camada 1
//   bias1: State para bias da camada 1
//   weights2: State para pesos da camada 2
//   bias2: State para bias da camada 2
//
// Total: 4 States = 64 bytes (modelo mínimo)
// Para modelo completo (16x16 pesos): 544 States = 8,704 bytes

// =============================================================================
// Inicialização de Pesos
// =============================================================================

// Inicializa pesos do classificador com semente
pub fn init_classifier_weights(seed: Float) -> State {
    return init_weights(seed);
}

// Inicializa bias zerado
pub fn init_classifier_bias() -> State {
    return init_bias_zero();
}

// Cria conjunto completo de pesos (4 States empacotados conceitualmente)
// Retorna weights1 (use com diferentes seeds para cada componente)
pub fn init_model_weights(seed: Int) -> State {
    let sf = float_from_int(seed);
    return init_weights(sf);
}

// =============================================================================
// Forward Pass
// =============================================================================

// Forward pass completo do classificador
// input: State codificado do encoder
// w1, b1: pesos e bias da camada 1
// w2, b2: pesos e bias da camada 2
// Retorna: probabilidades softmax (16 classes)
pub fn classifier_forward(
    input: State,
    w1: State,
    b1: State,
    w2: State,
    b2: State
) -> State {
    // Camada 1: Dense + ReLU
    let h1 = dense_relu(input, w1, b1);

    // Camada 2: Dense
    let logits = dense_forward(h1, w2, b2);

    // Softmax para probabilidades
    return softmax(logits);
}

// Forward pass para treinamento (retorna logits antes do softmax)
pub fn classifier_forward_logits(
    input: State,
    w1: State,
    b1: State,
    w2: State,
    b2: State
) -> State {
    let h1 = dense_relu(input, w1, b1);
    return dense_forward(h1, w2, b2);
}

// Forward pass simplificado (1 camada apenas)
pub fn classifier_simple(input: State, weights: State, bias: State) -> State {
    let logits = dense_forward(input, weights, bias);
    return softmax(logits);
}

// =============================================================================
// Inferência
// =============================================================================

// Inferência com modelo completo
pub fn classifier_inference(input: State, w1: State, b1: State, w2: State, b2: State) -> State {
    return classifier_forward(input, w1, b1, w2, b2);
}

// Obtém classe predita (argmax)
pub fn predict_class(probs: State) -> Int {
    let max_prob = 0.0;
    let max_idx = 0;

    let p0 = bs_mag(st_get(probs, 0));
    if p0 > max_prob { let max_prob = p0; let max_idx = 0; }

    let p1 = bs_mag(st_get(probs, 1));
    if p1 > max_prob { let max_prob = p1; let max_idx = 1; }

    let p2 = bs_mag(st_get(probs, 2));
    if p2 > max_prob { let max_prob = p2; let max_idx = 2; }

    let p3 = bs_mag(st_get(probs, 3));
    if p3 > max_prob { let max_prob = p3; let max_idx = 3; }

    let p4 = bs_mag(st_get(probs, 4));
    if p4 > max_prob { let max_prob = p4; let max_idx = 4; }

    let p5 = bs_mag(st_get(probs, 5));
    if p5 > max_prob { let max_prob = p5; let max_idx = 5; }

    let p6 = bs_mag(st_get(probs, 6));
    if p6 > max_prob { let max_prob = p6; let max_idx = 6; }

    let p7 = bs_mag(st_get(probs, 7));
    if p7 > max_prob { let max_prob = p7; let max_idx = 7; }

    let p8 = bs_mag(st_get(probs, 8));
    if p8 > max_prob { let max_prob = p8; let max_idx = 8; }

    let p9 = bs_mag(st_get(probs, 9));
    if p9 > max_prob { let max_prob = p9; let max_idx = 9; }

    let p10 = bs_mag(st_get(probs, 10));
    if p10 > max_prob { let max_prob = p10; let max_idx = 10; }

    let p11 = bs_mag(st_get(probs, 11));
    if p11 > max_prob { let max_prob = p11; let max_idx = 11; }

    let p12 = bs_mag(st_get(probs, 12));
    if p12 > max_prob { let max_prob = p12; let max_idx = 12; }

    let p13 = bs_mag(st_get(probs, 13));
    if p13 > max_prob { let max_prob = p13; let max_idx = 13; }

    let p14 = bs_mag(st_get(probs, 14));
    if p14 > max_prob { let max_prob = p14; let max_idx = 14; }

    let p15 = bs_mag(st_get(probs, 15));
    if p15 > max_prob { let max_prob = p15; let max_idx = 15; }

    return max_idx;
}

// Obtém probabilidade máxima (confiança)
pub fn predict_confidence(probs: State) -> Float {
    let max_prob = 0.0;

    let p0 = bs_mag(st_get(probs, 0));
    if p0 > max_prob { let max_prob = p0; }

    let p1 = bs_mag(st_get(probs, 1));
    if p1 > max_prob { let max_prob = p1; }

    let p2 = bs_mag(st_get(probs, 2));
    if p2 > max_prob { let max_prob = p2; }

    let p3 = bs_mag(st_get(probs, 3));
    if p3 > max_prob { let max_prob = p3; }

    let p4 = bs_mag(st_get(probs, 4));
    if p4 > max_prob { let max_prob = p4; }

    let p5 = bs_mag(st_get(probs, 5));
    if p5 > max_prob { let max_prob = p5; }

    let p6 = bs_mag(st_get(probs, 6));
    if p6 > max_prob { let max_prob = p6; }

    let p7 = bs_mag(st_get(probs, 7));
    if p7 > max_prob { let max_prob = p7; }

    let p8 = bs_mag(st_get(probs, 8));
    if p8 > max_prob { let max_prob = p8; }

    let p9 = bs_mag(st_get(probs, 9));
    if p9 > max_prob { let max_prob = p9; }

    let p10 = bs_mag(st_get(probs, 10));
    if p10 > max_prob { let max_prob = p10; }

    let p11 = bs_mag(st_get(probs, 11));
    if p11 > max_prob { let max_prob = p11; }

    let p12 = bs_mag(st_get(probs, 12));
    if p12 > max_prob { let max_prob = p12; }

    let p13 = bs_mag(st_get(probs, 13));
    if p13 > max_prob { let max_prob = p13; }

    let p14 = bs_mag(st_get(probs, 14));
    if p14 > max_prob { let max_prob = p14; }

    let p15 = bs_mag(st_get(probs, 15));
    if p15 > max_prob { let max_prob = p15; }

    return max_prob;
}

// =============================================================================
// Utilitários
// =============================================================================

// Calcula tamanho do modelo em bytes
pub fn model_size_bytes() -> Int {
    // 4 States (w1, b1, w2, b2) x 16 bytes cada
    return 64;
}

// Calcula tamanho do modelo completo (16x16 pesos por camada)
pub fn model_size_full_bytes() -> Int {
    // 2 camadas x (256 pesos + 16 bias) x 16 bytes
    return 8704;
}
